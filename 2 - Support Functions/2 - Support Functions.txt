

--------------------------------------------------------------------------------
-- INPUT: VALIDATE NAME --------------------------------------------------------

This is a much more powerful function than I realized, as it does the following tricks, which we well need:

	* Does not care about instance names.
	* Will return multiple matches with a wildcard: <name>*
	* It will return the above in the searched order

--

Simply find a stat in the data dictionary (does little checking)

0: stat name searched for
1: instance, if applicable
returns: full.attribute_()
(removes substat; just looks for attribute)

q0: Basic stat
q1: Basic stat search
q2: Outcome of basic stat search
q3: Outcome of literal stat search
q4: Final outcome

qz, qa, qb: Regmatch results

--

&f.statpath-validate-name sfp=
localize(

@@ spaces to underscores
@@ (and, cheating, ignore the instance)
	[setq(0, edit(first(%0, .), %b, _))]

@@ instanced?
	[setq(1, 
		if(
			regmatch(%q0, %(.*%)%\(%(.*%)%\), z a b), 
			[trim(%qa, b, _)]*_%(%), 
			%q0*
		)
	)]

@@ look for all possibilities in data dictionary
@@ then filter it down and grab it by order
	[setq(2, 
		sortby(
			sortby.types, 
			filter(
				filter.search-types, 
				u(f.stat-list-selected, %q1)
			)
		)
	)]
	
@@ (look for literal match FIRST, THEN grab first sorted outcome)
	[setq(4, 
		if(
			t(setr(3, graball(%q2, *.%q0))), 
			%q3, 
			first(%q2)
		)
	)]

@@ return: did I get anything?
	[if(t(%q4), %q4, #-1 STAT NOT FOUND)]
)

---

&f.statpath-validate-name sfp=localize([setq(0, edit(first(%0, .), %b, _))][setq(1, if(regmatch(%q0, %(.*%)%\(%(.*%)%\), z a b), [trim(%qa, b, _)]*_%(%), %q0*))][setq(2, sortby(sortby.types, filter(filter.search-types, u(f.stat-list-selected, %q1))))][setq(4, if(t(setr(3, graball(%q2, *.%q0))), %q3, first(%q2)))][if(t(%q4), %q4, #-1 STAT NOT FOUND)])

---

think u(sfp/f.statpath-validate-name, stren)
think u(sfp/f.statpath-validate-name, lang, fr)
think u(sfp/f.statpath-validate-name, court)
think u(sfp/f.statpath-validate-name, cour)

think u(sfp/f.statpath-validate-name, lang(french))

think u(sfp/f.statpath-validate-name, la*)


--------------------------------------------------------------------------------
-- INPUT: BREAKDOWN REGISTERS --------------------------------------------------

0: <stat>[ (<instance>)][.<substat>]
   "<stat>(<instance>)" and "<stat>(<instance>" should both also work
Output: Sets qx, qy, qz -- intended not to be localized!

That is, the proper use of this is to pass in a player-inputted stat
and populate these registers for further processing

--

&f.stat-input-breakdown-registers sfp=

[setq(z, squish(edit(%0, %(, %b%()))]

[setq(x, trim(before(before(%qz, .), %()))]
[setq(y, before(rest(before(%qz, .), %(), %)))]
[setq(z, rest(%qz, .))]

--

think [u(sfp/f.stat-input-breakdown-registers, lit(get(foo).yay))]%qx.%qy.%qz

-=> get.foo.yay


--------------------------------------------------------------------------------
-- INPUT: INSTANCE IS NULL? ----------------------------------------------------

There is a difference between having no instance and having a null instance
Returns 1 if null instance, else returns 0.

0: stat as entered
Returns: 1 if instance is there but null, 0 otherwise

--

&f.stat-input-instance-is-null? sfp=regmatch(%0, .*%\(%\))


--------------------------------------------------------------------------------
-- GET CLASS -------------------------------------------------------------------

Get what kind of class a <statpath> is.  If only we did this in a more object-oriented manner.

0: full stat path (may include substat!)
returns: class.<statpath> or "numeric" if null

--

&f.get-class sfp=
	udefault(
		[u(d.data-dictionary)]/
		class.[u(f.statpath-without-instance, extract(%0, 1, 2, .))], 
		numeric
	)

--

think u(sfp/f.get-class, attribute.strength)
think u(sfp/f.get-class, bio.template)
think u(sfp/f.get-class, bio.full_name)


--------------------------------------------------------------------------------
-- ISCLASS? --------------------------------------------------------------------

Does the class of the stat path match any of the passed parameters?

0: full stat path (may include substat!)
1: space-delimited class types to find
returns: 1 or 0

--

&f.isclass? sfp=t(match(%1, ulocal(f.get-class, %0)))

--

think u(sfp/f.isclass?, attribute.strength, string)
think u(sfp/f.isclass?, attribute.strength, numeric string)

think u(sfp/f.isclass?, gift.full_moon, list)



===============================================================================
== STATPATH FUNCTIONS =========================================================

The following functions care about where a stat is, exactly, on the data dictionary or a character sheet.  All additions to stats are in the format of <what>.<statpath>, such as tags.<statpath>.


--------------------------------------------------------------------------------
-- STATPATH: DATA DICTIONARY ---------------------------------------------------

Use this if we know that the path we're looking for is on the data dictionary itself.

Because the "substat" section for List stats is only for lookup, we will return only the type.name portion for list stats.  (Remember to do the same for sheet, below.)

--

0: stat name[ (instance)][.substat]
returns: stat_name[_(instance)][.substat]

qn: Validated (then later, built) stat name
qs: stat dd entry
qc: stat class
qi: instance passed, returned WITH UNDERSCORES
q0, 1: tmp result holders
qx, y, z: stat name, instance, substat to be validated

This version validates from the Data Dictionary ONLY.
MORE PERMISSIVE than statname-lookup-sheet, as * is "anything"
Used for validating new purchases if sheet-lookup fails.

--

&f.statpath-lookup-dd sfp=

@@ Break down stat into registers x, y, z
[setq(0, edit(%0, _, %b))]
[u(f.stat-input-breakdown-registers, %q0)]

@@ validate stat name:
[if(
	setr(n, u(f.statpath-validate-name, %q0)), 

@@ .. get dd entry
	[setq(s, u(v(d.data-dictionary)/%qn))]
@@ .. get dd entry's "class" (we're guaranteed no instance here)
	[setq(c, udefault(v(d.data-dictionary)/class.%qn, numeric))]

@@ >> if instance, check dd entry for that instance and if not found, error
@@ .. we are expecting an instance if validated stat name ends in ()
	[if(
		strmatch(%qn, *_%(%)), 
		switch(
			1, 
@@ .. .. instance list is *, return exactly what we were passed
			strmatch(*, setr(1, extract(%qs, 2, 1, |))), 
			setq(n, [before(%qn, _%(%))]_%([edit(%qy, %b, _)]%)), 
@@ .. .. expecting specific instance, none passed
			match(%qy, ), 
			setq(n, #-2 INSTANCE NOT FOUND), 
@@ .. .. instance list is something else and we can find what was passed on it
			t(setr(0, grab(%q1, %qy*, .))), 
			setq(n, [before(%qn, _%(%))]_%([edit(%q0, %b, _)]%)), 
@@ .. .. all other conditions failed: error
			setq(n, #-2 INSTANCE NOT FOUND)
		)
	)]

@@ >> if substat, check dd entry for that substat and if not found, error
	[if(
		and(t(%qz), t(%qn)), 
		switch(
			1, 
@@ .. .. substat-list is *
@@ .. .. (our dd format shifts the substat-list at instance-list +1)
@@ .. .. (for dd-lookup, the instance may be null and still valid)
			setr(1, 
				strmatch(*, 
					extract(%qs, add(2, t(regmatch(%qn, .*%\(.*%\)))), 1, |)
				)
			), 
			setq(n, %qn.[edit(%qz, %b, _)]), 
@@ .. .. substat-list is an actual list
			t(setr(0, grab(%q1, %qz*, .))), 
			setq(n, %qn.%q0), 
@@ .. .. no matches
			setq(n, #-2 SUBSTAT NOT FOUND)
		)
	)]
)]

@@ return built stat, or error -- for class:list stats, type.name only
[if(and(t(%qn), strmatch(%qc, list)), extract(%qn, 1, 2, .), %qn)]

--

think u(sfp/f.statpath-lookup-dd, str)
think u(sfp/f.statpath-lookup-dd, c (su))
think u(sfp/f.statpath-lookup-dd, aca.lib)

think statpath(court)
think statpath(cour)
think statpath(cour(s))
think statpath(lang ())
think statpath(lang ().ft)

think ## [setr(0, lit(str|l (French)|aca.Library Science|mantle (courtless)))] %r--> [iter(%q0, u(sfp/f.statpath-lookup-dd, ##), |, %r-->%b)]


--------------------------------------------------------------------------------
-- STATPATH: WITHOUT INSTANCE --------------------------------------------------

Reverses the statpath process, taking a stat from the sheet and stripping the instance from it.  Generally used to then look up things directly on the data dictionary itself.

0: Full statpath
qz: temp holder to grab just the name portion of a stapath

--

&f.statpath-without-instance sfp=localize(if(regmatchi(%0, %(.*%)%\(.*%\), z z), %qz%(%), %0))

--

think u(sfp/f.statpath-without-instance, statpath(strength))
think u(sfp/f.statpath-without-instance, statpath(cour(sp)))
think u(sfp/f.statpath-without-instance, statpath(lang (spanish)))


--------------------------------------------------------------------------------
-- STATPATH: SHEET -------------------------------------------------------------

Use this when we know (or suspect) the stat we're looking for is on the character's sheet.  It's quicker to start with the sheet lookup then, if that doesn't work, check (without instance) on the data dictionary.

YES, LOOKUP-SHEET PRACTICALLY VALIDATES THE STAT ON THE SHEET, BUT NOT ENTIRELY

--

0: player dbref
1: stat name[ (instance)][.substat]
returns: stat path: stat_name[_(instance)][.substat]

qn: Validated stat name
qs: stat dd entry
qc: class from stat dd entry
q0: tmp result holder
qx, y, z: stat name, instance, substat to be validated (from another func)

NOTE: Instances and Substats on sheet are stored with _ for spaces

--

&f.statpath-lookup-sheet sfp=

@@ until I can figure out how to have this and lookup-dd work together:

@@ Break down stat into registers x, y, z
[setq(0, edit(%1, _, %b))]
[u(f.stat-input-breakdown-registers, %q0)]
[setq(y, edit(%qy, %b, _))]

@@ validate stat name:
[if(
	setr(n, u(f.statpath-validate-name, %q0)), 

	[setq(s, u(v(d.data-dictionary)/%qn))]
	[setq(c, u(f.get-class, %qn))]

@@ .. validate instance, if any
	[if(
@@ .. we are expecting an instance if validated stat name ends in ()
		strmatch(%qn, *_%(%)), 
@@ .. .. dd lookup, else sheet lookup, else error
		switch(
			1, 
@@ .. .. .. instance nowhere, because it wasn't passed
			match(%qy, ), 
			setq(n, #-2 INSTANCE NOT FOUND), 
@@ .. .. .. instance on dd
			t(setr(0, grab(extract(%qs, 2, 1, |), %qy*, .))), 
			setq(n, [before(%qn, _%(%))]_%(%q0%)), 

@@ .. .. .. instance on sheet
			t(setr(0, lattr(u(f.find-sheet, %0)/_[before(%qn, _%(%))]_%(%qy*%)))), 
			setq(n, rest(%q0, _)), 
@@ .. .. .. instance nowhere, because nothing else matched
			setq(n, #-2 INSTANCE NOT FOUND)
		)
	)]

	[if(
		and(t(%qz), t(%qn)), 
@@ .. .. dd lookup, else sheet lookup, else error
		switch(
			1, 
			t(setr(0, grab(extract(%qs, add(2, t(%qy)), 1, |), %qz*, .))), 
			setq(n, %qn.%q0), 
			t(setr(0, lattr(u(f.find-sheet, %0)/_%qn.[edit(%qz, %b, _)]*))), 
			setq(n, rest(%q0, _)), 
			setq(n, #-2 SUBSTAT NOT FOUND)
		)
	)]
)]

@@ return built stat, or error -- for class:list stats, type.name only
[if(and(t(%qn), strmatch(%qc, list)), extract(%qn, 1, 2, .), %qn)]

--

think u(sfp/f.statpath-lookup-sheet, %!, str)
think u(sfp/f.statpath-lookup-sheet, %!, c (s))
think u(sfp/f.statpath-lookup-sheet, %!, cont.rep)
think u(sfp/f.statpath-lookup-sheet, %!, lang (fr))

think [setq(0, lit(str|l (French)|athl.quick r|mantle (sp)))][setq(1, pmatch(thenomain))][iter(%q0, ==> [ljust(%q1/##, 15)] --> [statname(%q1/##)], |, %r)]



================================================================================
== PREREQUITE FUNCTIONS ========================================================

We check format, stat path, and roughly check the value.  Here we also check the types of prerequisites imposed upon us by ourselves in &prerequisite.<statpath>, but also by the Storytelling system.  I'll try to be careful to notate which is which.

These functions do minimal error-checking.

Failed prerequisites should always return #-3 <reason> and be checked after value-checking.


--------------------------------------------------------------------------------
-- PREREQ: OTHER ---------------------------------------------------------------

We'll start with the most generic of prerequisite checks, stored on &prerequisite.<statpath>.  The error message when this check fails are pulled from &prereq-text.<statpath>

Remember we pass to prerequisite.<statpath> the following:
	0: dbref of sheet
	1: instance of stat, if any
	2: stat-raise (offset) if stat being checked is being raised (used in cg/xp)

returns: 1 if valid, #-1 <reason> if not

p: return for &prerequisite.<statpath>

--


&f.prereq-check-other sfp=

localize(
	[setq(
		p, 
		ulocal([u(d.data-dictionary)]/prerequisite.%1, %0, edit(%2, %b, _), %3)
	)]
	[case(
		0, 
		comp(%qp, ), 1, 
		%qp, #-3 [u([u(d.data-dictionary)]/prereq-text.%1, %0, edit(%2, _, %b), %3)], 
		1
	)]
)

--

think u(sfp/f.prereq-check-other, pmatch(dog), merit.mantle_(), spring)
think u(sfp/f.prereq-check-other, pmatch(dog), merit.court_goodwill_(), spring)

think u(sfp/f.prereq-check-other, pmatch(gwen), merit.mantle_(), spring, 1)
think u(sfp/f.prereq-check-other, pmatch(gwen), merit.court_goodwill_(), spring, 1)

think u(sfp/f.prereq-check-other, pmatch(thenomain), contract.fleeting_spring, spring, 1)
think u(sfp/f.prereq-check-other, pmatch(thenomain), contract.fleeting_spring, spring, 5)

think u(sfp/f.prereq-check-other, pmatch(gwen), contract.fleeting_spring, spring, 1)
think u(sfp/f.prereq-check-other, pmatch(gwen), contract.fleeting_spring, spring, 5)

think u(sfp/f.prereq-check-other, pmatch(jade), merit.workshop_(), Washington's_Obsequy)
think u(sfp/f.prereq-check-other, pmatch(jade), merit.workshop_(), Washington's_Obsequy, 1)


--------------------------------------------------------------------------------
-- PREREQ: CGEN ----------------------------------------------------------------

Some stats are cgen-only.  We are not going to enforce this, but add this function to the stat system for completeness.

Please note that unlike other support functions, we're sending the player dbref, not the sheet dbref.  Fine-tune this for your own game.

may use zones in the future
0: player dbref
1: full.statpath
returns: 1 if valid, #-1 <reason> if not

--

&f.prereq-check-cgen sfp=
	if(
		or(
@@ .. player is in chargen
			strmatch(loc(%0), #xxx), 
@@ .. stat is not cg-only
			not(u(f.hastag?.workhorse, %1, chargen-only))
		), 
		1, 
		#-3 Stat May Only Be Purchased At Character Generation
	)

---

think u(sfp/f.prereq-check-cgen, pmatch(thenomain), attribute.presence)
think u(sfp/f.prereq-check-cgen, pmatch(thenomain), merit.encyclopedic_knowledge)


--------------------------------------------------------------------------------
-- PREREQ: TEMPLATE ------------------------------------------------------------

I know the stat system as a whole doesn't normally care about this, but to validate setstat(), we'll need this.

Templates are only important for the Storytelling (etc) systems, but I can see it being used in other systems as well.  Say only your Anita Blake Vampires can have the Sexy Fangs stat.

Requires the Data Dictionary to have &bio.template, and &tags.<statpath> to include the stat.  If &tags.<statpath> has no templates in it, then it will be considered valid.  (So even if you don't use templates, this system won't hurt anything, just be extra code.)

See Also: setstat(), where this will be used.

--

0: sheet dbref
1: full.statpath_()
returns: 1 if valid, #-1 <reason> if not

d: data dictionary dbref (we use it that often)
b: bio.templates
t: templates used in tags.<statpath>

--

&f.prereq-check-template sfp=
localize(
	[setq(d, u(d.data-dictionary))]
	[setq(b, lcstr(u(%qd/bio.template)))]
	[setq(t, setinter(lcstr(u(%qd/tags.%1)), %qb, .))]
	[case(
		0, 
@@ .. stat uses no templates, so is valid to all templates
		comp(%qt, ), 1, 
@@ .. check the intersection of stat's templates with sheet's
		comp(setinter(%qt, lcstr(u(%0/_bio.template)), .), ), 
		#-3 Stat Not Allowed For This Template, 
@@ .. no other errors, so 1
		1
	)]	
)

--

think u(sfp/f.prereq-check-template, pmatch(thenomain), merit.unseen_sense_())
think u(sfp/f.prereq-check-template, pmatch(thenomain), merit.mantle_())
think u(sfp/f.prereq-check-template, pmatch(thenomain), attribute.strength)



@@ =============================================================================
@@ == PRIMARY FUNCTIONS ========================================================
@@ =============================================================================

You know, the reason we do this.

== statpath([<player>/]<stat>) ================================================

USER-DEFINED FUNCTION: STATPATH()

This function is simply an API-like function that allows a staffer-project to pull the raw "where would I find this stat" via the statname-lookup functions, and do some additional error checking.

&f.statpath sfp=
@@ 0: As passed, will be broken apart.
@@ Output: Full stat path or #-1 or whatever (via f.statpath.workhorse).
@@ 
@@ qp: Player to check.
@@ qs: Stat to check.

@@ Prime the registers.  If it hurts your brain, it hurts mine too.
[setq(s, )][setq(p, )]
[setq(s, if(t(setr(s, rest(%0, /))), %qs[setq(p, before(%0, /))], %0))]

@@ Validate Input

[case(
	0, 
@@ .. staff-only
	isstaff(%@), 
	#-1 STAFF ONLY, 
@@ .. must have a stat to look up
	comp(%qs, ), 
	#-1 NEED STAT TO LOOK UP,  
@@ .. else call the Workhorse.  If it hurts your brain, tough.
	ulocal(f.statpath.workhorse, %qs, %qp)
)]

---

&f.statpath.workhorse sfp=
@@ 0: Stat to check.
@@ 1: Player dbref of target, if any
@@ Output: Full stat path or #-1 Whatever
@@ 
@@ qp: Dbref of player then of player's sheet


@@ If player, do the player dance, else do the dd-lookup dance.
@@ If player but player lookup failed, also do the dd-lookup dance.
	[if(
		t(%1), 
@@ .. .. player error-checking
		case(
			0, 
			t(setr(p, pmatch+(%1))), 
			#-1 PLAYER NOT FOUND, 
			t(setr(p, u(f.find-sheet, %qp))), 
			#-1 SHEET NOT FOUND, 
@@ .. .. .. okay, do the lookup
			setq(p, ulocal(f.statpath-lookup-sheet, %qp, %0))
		), 
@@ .. .. plain dd-lookup
		setq(p, ulocal(f.statpath-lookup-dd, %0))
	)]
	[if(
@@ If dbref passed, and the player lookup failed...
		and(t(%1), strmatch(%qp, #-*)), 
@@ .. try the dd lookup
		ulocal(f.statpath-lookup-dd, %0), 
@@ .. else output whatever we have
		%qp
	)]

---

&f.statpath sfp=[setq(s, )][setq(p, )][setq(s, if(t(setr(s, rest(%0, /))), %qs[setq(p, before(%0, /))], %0))][case(0, isstaff(%@), #-1 STAFF ONLY, comp(%qs, ), #-1 NEED STAT TO LOOK UP,  ulocal(f.statpath.workhorse, %qs, %qp))]

@@ Current: 
&f.statpath.workhorse sfp=[if(t(%1), case(0, t(setr(p, pmatch+(%1))), #-1 PLAYER NOT FOUND, t(setr(p, u(f.find-sheet, %qp))), #-1 SHEET NOT FOUND, setq(p, ulocal(f.statpath-lookup-sheet, %qp, %0))), setq(p, ulocal(f.statpath-lookup-dd, %0)))][if(and(t(%1), strmatch(%qp, #-*)), ulocal(f.statpath-lookup-dd, %0), %qp)]

@@ Older:
	&f.statpath.workhorse sfp=if(t(%1), case(0, t(setr(p, pmatch+(%1))), #-1 PLAYER NOT FOUND, t(setr(p, u(f.find-sheet, %qp))), #-1 SHEET NOT FOUND, ulocal(f.statpath-lookup-sheet, %qp, %0)), ulocal(f.statpath-lookup-dd, %0))


---

USER-DEFINED FUNCTION: STATPATH()

== statname([<player>/]<stat>) ================================================

&f.statname sfp=
@@ 0: same as f.statpath
@@ output: prettified Just-The-Stat-Name
@@ qr: results of f.statpath

if(
	t(setr(r, u(f.statpath, %0))), 
@@ .. dd stat: send the name portion of the statpath
	u(f.statname.workhorse, rest(%qr, .)), 
@@ .. error: show what f.statpath handed us
	%qr
)

---

&f.statname.workhorse sfp=
@@ 0: The "rest" of the statpath (that is, just the name portion)

	iter(
@@ .. .. Step 1: Capitalize Words
		edit(%0, _, %b), 
@@ .. Step 2: Capitalize Substats
		titlestr(%i0), 
		., 
		.
	)

---

&f.statname sfp=if(t(setr(r, u(f.statpath, %0))), u(f.statname.workhorse, rest(%qr, .)), %qr)

&f.statname-workhorse sfp=iter(iter(edit(lcstr(%0), _, %b), capstr(##), ., .), capstr(##))

&f.statname.workhorse sfp=[setq(r, iter(iter(edit(lcstr(%0), _, %b), capstr(%i0)), capstr(%i0), ., .))][if(regmatch(%qr, %(.*%) %\%(%(.*%)%\%), m s i), %qs ([u(f.statname.workhorse, %qi)]), %qr)]

&f.statname.workhorse sfp=iter(edit(%0, _, %b), titlestr(%i0), ., .)

---

think iter(iter(edit(a_b.c_d, _, %b), capstr(##), ., .), capstr(##))

think statname(str)
think statname(cont.rep)
think statname(thenomain/cont.rep)
think statname(c(s))
think statname(blah)


== hasstat(<player>/<stat>) ====================================================

hasstat(<player>/<stat>) - ??? Do We Need This?


== getstat(<player>/<stat>[, <statstuff>]) =====================================

Getstat is checked against f.statpath, which gets us 2/3rds of what we need.

<statstuff>: 
- [p]ermanent: return the first part, if numeric
- [o]ffset: return the second part, if first part is numeric
- [b]oth: return <perm>.<offset>
- [t]otal: default, return <perm> + <offset>

p, o, b and t are ignored if the stat is non-numeric.


&f.getstat sfp=
@@ 0: <player>/<stat>
@@ 1: [p]ermanent, [o]ffset, [b]oth, [t]otal, if any
@@ 
@@ qp: <player>
@@ qs: <stat>
@@ qd: dbref of sheet
@@ 
@@ requires: isstaff(<dbref>), pmatch+(<player|"me">)

[setq(p, pmatch+(before(%0, /)))]
[setq(s, rest(%0, /))]

[case(
	0, 
@@ the following may work without objeval(<wiz>, getstat(xx/yy))
@@	or(isstaff(%@), strmatch(%qp, %#)), 
	isstaff(%@), 
	#-1 PERMISSION DENIED, 
	t(%qp), 
	#-1 PLAYER NOT FOUND, 
	t(setr(d, u(f.find-sheet, %qp))), 
	#-1 SHEET NOT FOUND, 
	t(%qs), 
	#-1 STAT MUST BE PROVIDED, 
	u(f.getstat.workhorse, %qp, %qs, %qd, %1)
)]

---

&f.getstat.workhorse sfp=
@@ 0: Player dbref
@@ 1: Stat to Get
@@ 2: Sheet Loc
@@ 3: [p]ermanent, [o]ffset, [b]oth, [t]otal, if any
@@ 
@@ qs: <stat path>, then <stat>'s location if character would have it
@@ qd: <stat> details if on sheet
@@ qc: class of <stat path>: numeric, string, list

[setq(s, u(f.statpath.workhorse, %1, %0))]
[setq(d, u(%2/_%qs))]
[setq(c, u(f.get-class, %qs))]


[if(
	t(%qs), 
@@ .. Stat Location Valid & Found
	case(
		%qc, 
@@ >> Statpath's Class: String (ignore %3, give all)
		string, %qd, 
@@ >> Statpath's Class: List (ignore %3, give all)
		list, %qd, 
@@ >> Statpath's Class: Number (follow %3)
		numeric, 
		switch(
			%3, 
			p*, first(%qd, .), 
			o*, rest(%qd, .), 
			b*, %qd, 
			t*, ladd(%qd, .), 
			ladd(%qd, .)
		), 
@@ >> Else: Panic and return full stat
		%qd
	), 
@@ .. Error Looking Up Stat
	%qs
)]

--

&f.getstat sfp=[setq(p, pmatch+(before(%0, /)))][setq(s, rest(%0, /))][case(0, isstaff(%@), #-1 STAFF ONLY, t(%qp), #-1 PLAYER NOT FOUND, t(setr(d, u(f.find-sheet, %qp))), #-1 SHEET NOT FOUND, t(%qs), #-1 STAT MUST BE PROVIDED, u(f.getstat.workhorse, %qp, %qs, %qd, %1))]

&f.getstat.workhorse sfp=[setq(s, u(f.statpath.workhorse, %1, %0))][setq(d, u(%2/_%qs))][setq(c, u(f.get-class, %qs))][if(t(%qs), case(%qc, string, %qd, list, %qd, numeric, switch(%3, p*, first(%qd, .), o*, rest(%qd, .), b*, %qd, t*, ladd(%qd, .), ladd(%qd, .)), %qd), %qs)]


---

@@ General Test
think [statname(thenomain/cont.rep)]: [getstat(thenomain/cont.rep)]

think [iter(full name|c(sp)|athl|athl.quick|speed|kith|blah, --> [ansi(c, statname(thenomain/##))]: [getstat(thenomain/##)], |, %r)]

@@ List and String Lookups
think getstat(thenomain/kith)
think getstat(thenomain/full name)

@@ Numeric Without Offset Lookup
think getstat(thenomain/str)
think getstat(thenomain/str, perm)
think getstat(thenomain/str, offset)
think getstat(thenomain/str, both)
think getstat(thenomain/str, total)

@@ Numeric With Offset Lookup
think getstat(thenomain/speed)
think getstat(thenomain/speed, perm)
think getstat(thenomain/speed, offset)
think getstat(thenomain/speed, both)
think getstat(thenomain/speed, total)

@@ Non-Numeric Lookup
think getstat(thenomain/cont.rep)
think getstat(thenomain/cont.rep, perm)
think getstat(thenomain/cont.rep, offset)
think getstat(thenomain/cont.rep, both)
think getstat(thenomain/cont.rep, total)



@@ =============================================================================
@@ == AFTER-THOUGHTS ===========================================================
@@ =============================================================================


== List of Stats Based on Tags =================================================

Returns only the stats of a certain category (* for 'all') with a certain tag ('*' for 'don't filter', in which case don't use this function, use lattr(<sheet>/_<category>.*) and leave it at that).

&f.list-stats-tags sfp=
@@ list of stats on a sheet, based on passed tags
@@ 0: dbref of sheet
@@ 1: category (may be *)
@@ 2: tags.list (all required, if any, for 'mental', etc., * for 'all')
@@ 3: 'or' for the default behavior of hastag? (defaults to 'and')
@@ 
@@ returns: character sheet statpaths

	filter(
		fil.list-stats-tags, 
@@ .. lazy, so turning "_sheet.statpath" into "sheet.statpath" 
@@ .. so we can use the filter for non-sheet matches
		rest(edit(lattr(%0/_%1.*), %b_, %b), _), 
		, 
		, 
		%2, 
		not(strmatch(%3, or))
	)

--

&f.list-stats-tags sfp=filter(fil.list-stats-tags, rest(edit(lattr(%0/_%1.*), %b_, %b), _), , , %2, not(strmatch(%3, or)))


== Filter: Does this stat have these tags? =====================================

&fil.list-stats-tags sfp=
@@ Filter based on a tags list 
@@ 0: stat.path_(with or without instance)
@@ 1: tags.to.check.against
@@ 2: "0" for or, "1" for and

	ulocal(
		f.hastag?.workhorse,
		ulocal(f.statpath-without-instance, %0), 
		%1, 
		%2
	)

--

&fil.list-stats-tags sfp=ulocal(f.hastag?.workhorse,ulocal(f.statpath-without-instance, %0), %1, %2)


== Filter: Is This Stat One of These Types? ====================================

Probably duplicitous.

&fil.list-stats-types sfp=
@@ Filter based on a tags list 
@@ 0: stat.path_(with or without instance)
@@ 1: types to check against

	t(match(%1, first(%0, .)))

--

&fil.list-stats-types sfp=t(match(%1, first(%0, .)))


== Filter: Does This Stat Have One of These Values? ============================


Filter based on values list (value.value 2.value 3)

0: stat.path_(with or without instance)
1: values to check against

&fil.list-stats-values sfp=
	setunion(
		get([u(d.data-dictionary)]/[ulocal(f.statpath-without-instance, %0)]), 
		%1, 
		.
	)


---

think filter(sfp/fil.list-stats-tags, trim(edit(lattr(me/_*.*), %b_, %b), b, _), , , changeling)

think filter(sfp/fil.list-stats-types, trim(edit(lattr(me/_*.*), %b_, %b), b, _), , , attribute merit)

think [setq(0, merit)][setq(1, changeling)][filter(sfp/fil.list-stats-tags, lattr(dd/%q0.*), , , %q1, not(strmatch(%q2, or)))]



think filter(sfp/fil.list-stats-values, trim(edit(lattr(me/_*.*), %b_, %b), b, _), , , 4)

think filter(sfp/fil.list-stats-values, trim(edit(lattr(me/_*.*), %b_, %b), b, _), , , Changeling)


--------------------------------------------------------------------------------
-- THE PRETTYSTAT FUNCTION FOR CHARSHEET ---------------------------------------

This is out of place, but it takes the value and offset of a number, and outputs either stars or a number for that stat, prettified.

&f.pretty-stat-num sfp=
@@ 0: <base>.<offset>
@@ 1: stars?, 1 for stars, 0 for number
@@ output: Either **** or Value, with color representing if offset is + or -
@@ 
@@ qb: base
@@ qo: offset

localize(switch(
	[setq(b, first(%0, .))]
	[setq(o, rest(%0, .))]
	1, 
@@ if <value> or <offset> are non-numeric, forget it
	not(and(isnum(%qb), or(isnum(%qo), not(t(%qo))))), 
	ansi(hw, %0), 
@@ stars! + offset = wwwhh
	and(t(%1), gte(%qo, 0)), 
	ansi(w, [repeat(o, %qb)], g, [repeat(*, %qo)]), 
@@ stars! - offset = yyxxx
	and(t(%1), lt(%qo, 0)), 
	ansi(w, [repeat(o, add(%qb, %qo))], hx, [repeat(., min(abs(%qo), %qb))]), 
@@ number! + offset = g
	gt(%qo, 0), 
	ansi(ng, add(%qb, %qo)), 
@@ number! - offset = y
	lt(%qo, 0), 
	ansi(hy, add(%qb, %qo)), 
@@ else, number! + 0 = w
	ansi(w, %0)
))

---

&f.prettify-stat-num sfp=localize(switch([setq(b, first(%0, .))][setq(o, rest(%0, .))]1, not(and(isnum(%qb), or(isnum(%qo), not(t(%qo))))), ansi(w, %0), and(t(%1), gte(%qo, 0)), ansi(w, [repeat(o, %qb)], h, [repeat(*, %qo)]), and(t(%1), lt(%qo, 0)), ansi(w, [repeat(o, add(%qb, %qo))], hx, [repeat(., min(abs(%qo), %qb))]), gt(%qo, 0), ansi(ng, add(%qb, %qo)), lt(%qo, 0), ansi(hy, add(%qb, %qo)), ansi(w, %0)))

---

think [ansi(c, statname(setr(0, thenomain/str)))] [u(sfp/f.prettify-stat-num, setr(1, getstat(%q0, b)), 1)] ([u(sfp/f.prettify-stat-num, %q1)])

think [ansi(c, statname(setr(0, thenomain/glam)))] [u(sfp/f.prettify-stat-num, setr(1, getstat(%q0, b)), 1)] ([u(sfp/f.prettify-stat-num, %q1)])

think [ansi(c, statname(setr(0, thenomain/spee)))] [u(sfp/f.prettify-stat-num, setr(1, getstat(%q0, b)), 1)] ([u(sfp/f.prettify-stat-num, %q1)])

think [ansi(c, statname(setr(0, thenomain/cont.rep)))] [u(sfp/f.prettify-stat-num, setr(1, getstat(%q0, b)), 1)]

think u(sfp/f.prettify-stat-num, 4, 1)
think u(sfp/f.prettify-stat-num, 4.-1, 1)
think u(sfp/f.prettify-stat-num, 4.+1, 1)
think u(sfp/f.prettify-stat-num, 4)
think u(sfp/f.prettify-stat-num, 4.-1)
think u(sfp/f.prettify-stat-num, 4.+1)

think iter(str glam spee cont.rep, >> [ansi(g, statname(setr(0, thenomain/##)))]: [[u(sfp/f.prettify-stat-num, setr(1, getstat(%q0, b)), 1)]], , %r)




== THE COMMAND ================================================================

+setstat <player>/<stat>=[+|-]<value>

illegal characters for value: : ` <number>. (but only at the start)









Sets a player's stat to <value> or returns it to the default chargen value, which may be null or derived.

(Once I get the default value for the chargen object filled.)
(have +command use stattag to allow only for 'derived' tagged stats.)

Code Flow:

* validate sheet
* validate stat name
* validate stat value (or if it has a default).

Hmm.  Validate Value should be simple once we've Validated the Stat (and boy have we validated the fuck out of it.)

How do I best set up so they can set the offset ("boost") in this, or do I?

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=--==--=-=-=-=-=-=-=-=-==-==--=-=-==--

DATA DICTIONARY THOUGHTS: 

You say, “If your seeming or kith matches something in the tag list, affinity. If goblin matches something in the tag list, goblin. Else, non-affinity.”

Blue says, “Very near, though they don't scale in cost the same way. You just pay for the rank, straight up, without worrying about any ranks that came before.”

You say, “Werewolf's gifts are also bought at level, like goblin contracts, I think.”

You say, “I believe this is done because you can jump around.”

-- a reason to make "goblin_contract" just "contract" in the DD.

&xp.<type>: <value>??? - Willpower is always 8xp/dot.

May not be so important if I keep stat-lookup & character-advancement DDs separate. ---


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==--=-=-=--=-=-==-=--=-=-==---=-=-==-=--=-=-=

&HELP~stat_topics~+STAT #96=About Stats~+stat is a multi-functional command that lists information about stats available on the game. It only lists stats available to the players, which are almost all, but not all, stats on +sheet. (XP and health are notable exceptions.) Additionally, the staff version of this command allows staff to set the values on characters.%r%r[ansi(h, +stat)] : Does nothing.%r%r[ansi(h, +stat <stat>)] : Detailed information about <stat>. %r%r[ansi(h, +stat <stat>*)] : List of stats matching the wildcard and their stat category.%r%rFor a list of all stats available, [ansi(h, +stat *)].

&SHELP~STAT_COMMANDS~+STAT #102=Manipulating Stats~In addition to the commands listed in +help stat, staff may perform the following:%r%r[ansi(h, +stat/template <player>=<template>)] : Sets <player> up with the proper template. Right now we only have Human and Changeling.%r%r[ansi(h, +stat/wipe <player>)] : Wipes all stats from a player's sheet. Spams you with what they were set at. %r%r[ansi(h, +stat/set <player>/<stat> = <value>)] : Set a stat to that value. If value is "default", re-sets to initial and derived value.%r%r[ansi(h, +stat/set <player>/<stat> +|- <value>)] : Increase/decrease a stat by that amount. Numeric stats only.%r%r[ansi(h, +stat/offset <player>/<stat> = <value>)] : Same thing as /set, but plays with the offset. Numeric stats only. + and - also work.%r%r[ansi(h, +stat/override <player>/<stat> = <value>)] : Overrides the entire check system. Set any stat to anything.%r%rFor information about offset and override, see [ansi(h, +shelp setstat%(%))], which this command mainly calls.


&SHELP~CHARGEN~SETSTAT() #102=Setting the Stat, the Complex Way~[ansi(h, setstat%(<player>/<stat>%, <value>|default%[%, <behavior>%]%))]%r%rThis is the end-result of all other functions and stat code and will do all the validation needed to set almost anything on almost anyone. It won't allow you to set stats in categories that aren't in the search list (such as health), and it will give you a descriptive #-1 error message if it doesn't like what you did. As usual, it will name-complete as much as it can.%r%r> Setting a stat to "default" will set it to the default, if there is one. (Attributes default at "1", derived stats default at their derived formula.) %r%r> Setting the <behavior> to "offset" will, for numeric stats (think pools, including Clarity and Morality), create a temporary boost or decline without destroying the base stat. %r%r> Setting the <behavior> to "override" will ignore the value-check for stats. That is, you can set someone's Strength to "-1", "50", or "peanut brittle".%r%r> Default only works with the permanent stat value. Offset only works with numeric values. You can't override to default, you can't override an offset. If you want to do either of these things, override the entire stat.~[ansi(h, Examples)]%r%r%b think setstat(thenotest/willpo, 5)%r%b think setstat(thenotest/willpo, 2, off)%r%b think setstat(thenotest/willpo, peanut brittle, overr)%r%b think setstat(thenotest/willpo, default)%r%r%b think setstat(thenotest/fleeting summer, 5)

&SHELP~STAT_COMMANDS~+XP #102=Adding and Spending a Player's XP~>>> This is a purely temporary solution. <<<%r%r[ansi(h, +xp)] : See your own XP, open to all.%r[ansi(h, +xp <player>)] : See <player>'s XP.%r[ansi(h, +xp/add <player>=<amt>)] : Add <amt> to <player>'s total XP.%r[ansi(h, +xp/spend <player>=<amt>)] : "Spend" <amt> of <player>'s XP.%r%rTechnically, this last one subtracts to the offset of the player's XP stat, so it can act a bit touchy. At the moment, you can "give back" Spent XP with a +xp/spend player=-amt.%r%rThis does not increase stats at all. See [ansi(h, +shelp stat)] and use that in conjunction with +xp/spend for now.
