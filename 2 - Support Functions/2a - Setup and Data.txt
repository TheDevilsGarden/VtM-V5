/*
================================================================================
== SETUP =======================================================================
*/

@create Stat Functions Prototype <sfp>
@set sfp=inherit safe

@fo me=&d.sfp me=[num( stat functions prototype <sfp> )]


/*
================================================================================
== DATA ========================================================================
*/

@fo me=&d.data-dictionary [v( d.sfp )]=search( name=Data Dictionary <dd> )
@fo me=&d.data-tags [v( d.sfp )]=search( name=Data Tags <d:t> )
// @fo me=&d.cg [v( d.sfp )]=search( name=GMC Chargen <cg> )

@fo me=&d.sfp [v( d.dd )]=search( name=Stat Functions Prototype <sfp> )

/*
================================================================================
== DOT-FUNCTIONS ===============================================================

Dot-functions are things that are to be used often enough that they could be 
user-defined functions (and often are).

--------------------------------------------------------------------------------
-- Dot-Function: Grab Exact ----------------------------------------------------

	u( .grabexact, <list>, <item>[, <delim>] )

Will grab the exact match of '<item>'. If not found, it will return the first 
alphanumeric match of '<item>*'.

Using wildcards (*, ?) in '<item>' defeats the purpose; use 'grab' instead.
	
*/

&.grabexact [v( d.sfp )]=
	localize( 
		if( 
			t( setr( m, grab( %0, %1, %2, %2 ))), 
			%qm, 
			grab( sort( %0, ?, %2, %2 ), %1*, %2 )
		)
	)

/* 
--------------------------------------------------------------------------------
-- Dot-Function: Crumple -------------------------------------------------------

	u( .crumple, <list>, <delim> )

Removes all but one instance of <delim> inside <list>, and all outside.

*/

&.crumple [v( d.sfp )]=trim( squish( %0, %1 ), b, %1 )



/*
================================================================================
== SEARCH ORDER ================================================================

d.search-order: 
	When name matching, go through the various stat types in this order. 
	Therefore, "str" will match "strength" before "strength of the lion".

	This is technically now a function, but for historical reasons we'll 
	leave it as a data collection.

d.search-order-<##>-<gameline>:
	As long as ## is between 2 and 8, search in that order.
	`02` should be for powers
	`03` should be for less important additions, such as renown
	`04` should be for smaller, social additions, such as entitlements
	`09` should be for the least important traits, such as full name

e.g.: 
	core: (01) attribute skill merit advantage (09) bio
	vampire: (02) ... (03) ...
	demon: (02) embed exploit (03) demonic_form
	werewolf: (02) gift rite (03) renown

d.type.specials:
	These are stat classes that are not rollable nor settable via softcode.

--------------------------------------------------------------------------------
*/

&d.search-order sfp=iter( sort( lattr( %!/d.search-order-* )), v( %i0 ))
&d.search-order-01 sfp=attribute skill merit advantage
// &d.search-order-<##>-<gameline> sfp=<stuff>
&d.search-order-09 sfp=bio

&d.type.specials sfp=special health 

&filter.search-types sfp=t( match( u( d.search-order ), first( %0, . )))

&sortby.types sfp=
	[setq( o, u( d.search-order ))]
	[comp( match( %qo, first( %0, . )), match( %qo, first( %1, . )))]

// -----------------------------------------------------------------------------
// -- test --

think sortby( sfp/sortby.types, filter( sfp/filter.search-types, sort( lattr( dd/*.s* ))))

think sortby( sfp/sortby.types, filter( sfp/filter.search-types, sort( lattr( dd/*.str* ))))
