================================================================================
== DATA ========================================================================

@fo me=&d.data-dictionary sfp=[num( data dictionary <dd> )]



================================================================================
== SEARCH ORDER ================================================================

d.type-search-order: 
	When name matching, go through the various stat classes in this order. 
	Therefore, "str" will match "strength" before "strength of the lion".

	core: attribute skill merit advantage bio
	changeling: contract goblin_contract
	skinchangers: aspect
	werewolf: gift rite renown

d.type-specials:
	These are stat classes that are not rollable nor settable via softcode.

--------------------------------------------------------------------------------
	
&d.type-search-order sfp=attribute skill merit advantage contract renown gift aspect goblin_contract rite bio

&d.type-specials sfp=special health

&sortby.types sfp=[comp(match(v(d.type-search-order), first(%0, .)), match(v(d.type-search-order), first(%1, .)))]

&filter.search-types sfp=t(match(v(d.type-search-order), first(%0, .)))

--------------------------------------------------------------------------------

think sortby(sfp/sortby.types, filter(sfp/filter.search-types, sort(lattr(dd/*.s*))))


================================================================================
== LIST STATS (SELECTED) =======================================================

Not only does this list the "valid search order" stats, but those not as well.
To list all, pass * or null.
To find middle matches, pass *<name>* or *<name>

--

0: Partial stat name to search for

--------------------------------------------------------------------------------

&f.stat-list-selected sfp=
	setunion(
		iter(
			[v(d.type-search-order)] [v(d.type-specials)], 
			lattr([u(d.data-dictionary)]/%i0.%0*)
		), 
	)

--------------------------------------------------------------------------------

think u(sfp/f.stat-list-selected, st)
think u(sfp/f.stat-list-selected, *str*)
think u(sfp/f.stat-list-selected, *ual_k*)



================================================================================
== FIND SHEET ==================================================================

character sheets might not be on the person they're meant to be on
this is a simple lookup function, in case things are changed

0: dbref of player
returns: dbref of sheet

--------------------------------------------------------------------------------

&f.find-sheet sfp=
@@ if the "sheet location" stat is on the passed item, pass that back
@@ else assume the sheet is on the player
	if(
		hasattr(%0, _special.sheet_location), 
		u(%0/_special.sheet_location),
		%0
	)



================================================================================
== STATVALUE-GOOD ==============================================================

It occurred to me, a bit late, that I could use a function that does nothing but check to see if the value someone is trying to set for a stat is bad.  Bad values are: 
	<value>.	- because the system thinks this is a numeric value
	`			- because the charsheet uses this as a delimiter

That's it for now.

0: The value
returns: 0 if bad, 1 if good

--------------------------------------------------------------------------------

&f.statvalue-good sfp=not(strmatch(%0, *`*))

--------------------------------------------------------------------------------

think u(sfp/f.statvalue-good, blah)

think u(sfp/f.statvalue-good, .blah)
think u(sfp/f.statvalue-good, blah.blah)
think u(sfp/f.statvalue-good, 10.blah)

think u(sfp/f.statvalue-good, `blah)
think u(sfp/f.statvalue-good, b`lah)
think u(sfp/f.statvalue-good, blah`)


