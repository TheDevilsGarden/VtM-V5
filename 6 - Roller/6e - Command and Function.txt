--------------------------------------------------------------------------------
-- Command: Roll ---------------------------------------------------------------

Cutting corners for now.

0: /list/of/switches
1: what to roll[= who to roll to]
uses: alert(), a formatting doodad

q0: what to roll, massaged
q9: target list (names or job #)

--

&c.roll nWoD Roller <nr>=$^\+?roll(.*) (.*)$:

	@pemit %#=
		strcat( 
@@ .. sanitize input and detach the instance
			setq( 0, before( %2, = )), 
			setq( 0, 
				squish( edit( 
					strip( %q0, %%%,;<>%[%] ), 
					%(, %b%( 
				))
			), 
@@ .. build the to-list
			setq( 9, trim( rest( %2, = ))), 
			setq( 9, case( 1, 
				strmatch( %q9, job * ), 
				job|%q9, 

				t( %q9 ), 
				private|
				[setunion( 
					iter( %# %q9, 
						if( setr( 9, pmatch( %i0 )), %q9 )
					), 
				)], 

				public|[lcon( loc( %# ), connect )] 
			)), 

@@ .. run the workhorse
			null( u( f.roll.workhorse, %q0, %#, %1 )), 

@@ .. interpret and output - check for errors first
			if( 
				t( words( %qe, ` )), 
				[u( .alert, roll )] [u( f.display.list, %qe )], 
@@ Roll To ...
				u( display.roll-to-[first( %q9, | )], %#, rest( %q9, | ))
			)
		)


--------------------------------------------------------------------------------
-- Function: roll() ------------------------------------------------------------

roll(<what to roll>, <who is rolling>[, <list/of/switches>])

0: what to roll
1: who is rolling
2: list/of/switches

q0: sanitized what-to-roll
q1: Sheet of pmatch(%1)
q2: /list/of/switches (we need this to properly match switches)

uses: 
	isstaff() - is %# staff?

--

Somehow, registers are being passed into this function set
(we are creating it @function/preserve/privileged)
so we clear out all the globals (and "p"?!) before we start
(no, iter didn't work)
"e" was adding to the error list, "p" was, I think, changing the player dbref

--

@fo me=&ufunc/privileged.roll nr=u\\( [num( nr )]/f.roll, \\\%0, \\\%1, \\\%2 \\)

--

&f.roll nWoD Roller <nr>=
	strcat( 
		setq( d, ), setq( a, ), setq( e, ), setq( o, ), setq( s, ), setq( z, ), 
		setq( r, ), setq( p, ), setq( t, ), setq( n, ), 

		setq( 0, squish( edit( strip( %0, %%%,;<>%[%] ), %(, %b%( ))), 
		setq( 1, u( [u(d.stat-setter)]/f.find-sheet, pmatch( %1 ))), 
		setq( 2, if( words( trim( %2, l, / ), / ), /[trim( %2, l, / )])), 

		case( 
			0, 
			t( words( %q0 )), #-1 Nothing to Roll, 
			t( %q1 ), %q1, 
			cor( 
				isstaff( %# ), 
				strmatch( %#, u( [u(d.stat-setter)]/f.find-sheet, %# ))), 
			#-1 Staff Only, 
			u( f.roll.workhorse, %q0, %q1, %q2 )
		)
	)


--------------------------------------------------------------------------------
-- Roll Workhorse --------------------------------------------------------------

0: what to roll
1: who is rolling
2: /list/of/switches

q0: successes
q1: success interpreted
q2: die rolls

returns: <successes or #-1>|<pretty output or errors>|<die rolls>
may be ignored if internal: items kept in global registers!

--

&f.roll.workhorse nWoD Roller <nr>=
	strcat( 
@@ .. set up global register defaults
		setq( z, u( f.switch.name-complete, %2 )), 
		setq( d, 0 ), 
		setq( a, 10 ), 
		setq( n, 0 ), 
		setq( t, ), 
		setq( c, ), 
		setq( s, Standard ), 
		
@@ .. run the basic roller setup
		u( f.stat-check.stats, %1, %0 ), 

@@ >> Active Adjustments <<
@@ .. scan for and run "active" switches
		iter(
			again weakness extended target, 
			if( u( f.hasswitch?, %i0 ), u( f.roll/%i0, u( f.getswitch, %i0 ))), 
			, @@ 
		), 

@@ .. last, check for health penalty
		u( f.stat-check.health, %1 ), 
		if( lte( %qd, 0 ), setq( s, Chance )), 

@@ >> ROLL <<
		if(
			t( words( %qe, ` )), 
@@ .. error output instead of rolling
			strcat( 
				#-1, |, 
				u( f.display-roll-items, %qe ), |, 
				@@( null )
			), 

			strcat( 

@@ .. tweak 'n-again' register (qa) if 'weakness' or 'chance' roll
@@ .. (this may not be necessary, put here in case my logic is flawed)
				setq( a, 
					case( 1, 
						u( f.hasswitch?, weakness ), 11, 
						strmatch( %qs, chance ), 10, 
						%qa
					)
				), 

@@ .. reset 'number of times to roll' register (qn) if not /extended or /target
				setq( n, 
					case( 1, 
						u( f.hasswitch?, extended ), %qn , 
						u( f.hasswitch?, target ), @@( null ), 
						1 
					)
				), 

@@ .. roll %qn times, at least once (if %qd = 0, roll 1 die -- it's chance)
				setq( r, 
					u( f.roll.workhorse.recurisve, 0, 0 )
				), 

@@ >> PARSE RESULTS
@@ .. <'target' should also go here to remove extraneous rolls>
@@ .. interpret successes -> <# succ>, "Success!", <what rolled>
				u( f.roll-success-interpreter ), 

@@ .. and output for the sake of the function 
@@ .. .. <# succ>[ <# succ>], <what rolled>, <dice>:<rote>:<n-again>[|<dice>:..]

				strcat( 
					trim( %qc ), |, 
					%q2, |, 
					trim( %qr, b, | )
				)
			)
		)
	)

--

think u(nr/f.roll.workhorse, str+dex+2, pmatch(thenomain), /again=8)
think u(nr/f.roll, str+2, thenomain, /again=8)

think roll(str+dex+2, thenomain, /again=8/extended)

think roll(str+2, thenomain, /again=8/extended=tyyt)



================================================================================
== Extended Roller =============================================================

A recursive roller for /extended and /target switches, 
otherwise defaults to one roll.

input
	0: loop counter (pass '0' initially)
	1: total successes  (pass '0' initially)
	qn: number of times to roll (default '1') -> /extended
	qt: target number (default <null>) -> /target
	qa: 'again' counter
	qd: dice to roll

output
	qc: success list/counter

internal
	q0: this loop's roll
	q1: this loop's successes

--

&f.roll.workhorse.recurisve nr=
	if( 
		cand( 
			cor( not( %qn ), lt( %0, %qn )), 
			cor( not( %qt ), lt( %1, %qt )), 
			cor( t( %qt ), t( %qn ), lt( %0, 1 ))
		), 
@@ roll some dice
		strcat( 
			setr( 0, 
				ulocal( f.roller, 
					if( lte( %qd, 0 ), 1, %qd ), 
					%qa, 
					if( u( f.hasswitch?, rote ), 8 )
				)
			), |, 

@@ count some successes
			setq( 1, u( f.successes.%qs, %q0, 8 )), 
			setq( c, %qc %q1 ), 

@@ do it again
			u( f.roll.workhorse.recurisve, inc( %0 ), add( %q1, %1 ))
		), 
@@ (last loop does nothing)

	)

