================================================================================
== ROLL PRIMER =================================================================

The following registers are used across the entire system:

    qd: Number: Total number of dice to roll (default 0)
        0: Use chance roller
        1+: Use normal roller
    qa: Number: The "again" to roll (default 10, 11 = "No 10-again")
    qe: Text: Error.list (default empty)
    qo: Text: Things.to.add to skill-list output (default empty)
    qs: Text: Which success system to use. (default "Standard")
        "Standard": Use the standard system
        "Weakness": Use the weakness system
    qz: Text: /Full/on/switches
    qr: Text: Result of dice throw, <throw>|<throw> if extended/multiple throws

    qt: Times to roll (default 1 unless /extended switch is used)

These registers are to be considered global and should not be touched out of context, for any reason.

See "Roll Switches", below, for details about how to add and include switches to roll.


================================================================================
== REGISTERS ===================================================================

Playing with the registers in a way where I know it will work properly.

In all cases, %0 is what to add.  In all cases, no error checking is done.  In all cases, there is to be no output.


--------------------------------------------------------------------------------
-- Add to Output (qo) ----------------------------------------------------------

0: stat name to add to output
1: sign (+ if <null>)
2: "nostat" if we want to error it

--

&f.registers.output-add nWoD Roller <nr>=
	setq( o, 
		%qo`
		[if( comp( %1, ), %1, + )] 
		[if( strmatch( %2, nostat ), ansi( xh, %[%0%] ), %0 )] 
	)


--------------------------------------------------------------------------------
-- Add to Dice (qd) ------------------------------------------------------------

&f.registers.dice-add nWoD Roller <nr>=setq( d, add( %qd, %0 ))


--------------------------------------------------------------------------------
-- Add to Errors (qe) ----------------------------------------------------------

&f.registers.error-add nWoD Roller <nr>=setq( e, %qe`%0 )


--------------------------------------------------------------------------------
-- Add to Number of Extended Rolls To Make (qt) --------------------------------

&f.registers.extendednum-add nWoD Roller <nr>=setq( t, add( %qt, %0 ))



================================================================================
== STAT CHECKS =================================================================

These functions build the basic what-to-roll list.  Stats, untrained penalties and wound penalties are all added here.


--------------------------------------------------------------------------------
-- Check for Stats -------------------------------------------------------------

Build the what-to-roll list with the stats.  If the system can pull the stat, it will roll it.

Doesn't deal with specialties at the same time as skills, yet, so:
	+roll dex + fire + fire.pist


>> here is where I would put in <player>:<stat>, if we would

--

0: Sheet dbref (player)
1: Things to roll
Outputs: Null -- see "roll primer"

q0: Current stat to check
q1: Current sign (+ or -)
q2: Current full stat name
q3: Current full stat path
q4: Current total stat value
q5: Current stat value, both
q6: Class of current full stat path (%q3)

--

&f.stat-check.stats nWoD Roller <nr>=
	iter( 
		edit( %1, -%b, -, -, +- ), 
		case( 1, 

@@ >> it's a number
			u( f.stat-check.number, %i0 ), 
			@@( number ), 

@@ >> it's possibly a stat
			strcat( 
@@ .. q0: stat as entered
@@ .. q1: current operation (+ or -)
				setq( 0, 
					trim(
						case( setr( 1, u( .sign, %i0 )), 
							-, 
							rest( %i0, - ), 
							%i0
						)
					)
				), 
@@ .. q3: full stat path
				setq( 3, 
					if( comp( %q0, ), 
						ulocal( [u(d.stat-setter)]/f.statpath.workhorse, 
							%q0, %0 
						), 
						setq( 0, %b )
					)
				)
@@ .. q2: full stat name
				setq( 2, 
					ulocal( [u(d.stat-setter)]/f.statname.workhorse, 
						rest( %q3, . )
					)
				), 
@@ .. not a valid trait?
				u( f.stat-check.invalid-trait, %0, %q0, %q1, %q3 )
			), 
			@@( not a valid trait ), 

@@ .. check trait
			u( f.stat-check.trait, %0, %q0, %q1, %q2, %q3 ),
			@@( we'll see what happens from there ), 
			
			#-1 Help I am confused 
		), , @@ 
	)


--------------------------------------------------------------------------------
-- Check for Untrained ---------------------------------------------------------

0: dbref of sheet
1: skill (full name is best, skills ONLY)
2: value of skill

--

&f.stat-check.skill nWoD Roller <nr>=

	if( 
		cand( 
			not( %2 ), 
			not( u( f.hasswitch?, tr ))
		), 
		case( 1, 
@@ untrained physcal or social
			hastag?( %1, physical.social, or ), 
			strcat( 
				u( f.registers.dice-add, -1 ), 
				u( f.registers.output-add, 1 %(untrained %1%), - ), 
				1 
			), 
@@ untrained mental
			hastag?( %1, mental ), 
			strcat( 
				u( f.registers.dice-add, -3 ), 
				u( f.registers.output-add, 1 %(untrained %1%), - ), 
				1 
			)
		), 

	)


--------------------------------------------------------------------------------
-- Check for Health Penalty ----------------------------------------------------

Add (subtract) health penalty unless passive /nowound switch is included

"now" is "nowounds" shortened

0: sheet dbref

--

&f.stat-check.health nWoD Roller <nr>=
	if( 
		cand( 
			not( u( f.hasswitch?, now )), 
			lt( setr( 0, ladd( u( .value_full, %0, health.penalty ), . )), 0 )
		), 
		[u( f.registers.output-add, [abs( %q0 )] %(wounds%), - )]
		[u( f.registers.dice-add, %q0 )]
	)


--------------------------------------------------------------------------------
-- Some Check Conditions -------------------------------------------------------

At the moment we don't have 'f.hasswitch?' in, so we can't check '/nowounds' or 
'/trained'.

think [u( nr/f.stat-check.stats, pmatch(me), strength + beauty + willpower + stealth + occult )]Output: %qo -- Dice: %qd -- Errors: %qe -- Again: %qa

think [u( nr/f.stat-check.stats, pmatch(me), strength + beauty + willpower + stealth + occult.bla )]Output: %qo -- Dice: %qd -- Extended Rolls: %qt




@@ number -> calculate

&f.stat-check.number nWoD Roller <nr>=
	if( 
		isint( %0 ), 
		strcat( 
			u( f.registers.dice-add, %0 ), 
			u( f.registers.output-add, abs( %0 ), u( .sign, %0 )), 
			1 
		)
	)

--


==--=-=-=-=-=-=-=-=-=-===--=-=-=-=-=-=-=-=-=-===--=-=-=-=-=-=-=-=-=-=

In all of the following:

0: sheet dbref
1: trait to check (player requested)
2: trait's sign (+ or -)
3: full trait name
4: full stat path

==--=-=-=-=-=-=-=-=-=-===--=-=-=-=-=-=-=-=-=-===--=-=-=-=-=-=-=-=-=-=


0: sheet dbref
1: trait to check (player requested)
2: full trait name

&f.stat-check.invalid-trait nWoD Roller <nr>=
	if( not( %4 ), 
		strcat( 
			u( f.registers.output-add, %1, %2, nostat ), 
			1 
		)
	)

--

@@ trait -> skill | calculate

&f.stat-check.trait nWoD Roller <nr>=
	if( 
		u( f.stat-check.skill, %0, %1, %2, %3, %4 ), 
		1, 

@@ ** I need to check for non-numerics and what to do with them here **
		strcat( 
@@ .. q5: stat's value (both)
@@ .. q6: stat's class
			setq( 5, getstat( %0/[first( %1, . )], both )), 
			setq( 6, ulocal( [u(d.stat-setter)]/f.get-class, %5 )), 

			udefault( f.stat-check.trait.%q6, 
				#-1 trait class not recognized, 
				%0, %1, %2, %3, %4, %q5  
			)
		)
	)

--

@@ trait.numeric -> calculate

&f.stat-check.trait.numeric nWoD Roller <nr>=
	strcat( 
		u( f.registers.dice-add, ladd( %5, . )), 
		u( f.registers.output-add, %2, %3 ), 
		u( f.registers.extendednum-add, ladd( %5, . )), 
		1 
	)

--

&f.stat-check.trait.string nWoD Roller <nr>=
	strcat( 
		u( f.registers.output-add, %2, %3, nostat ), 
		1 
	)

--

&f.stat-check.trait.list nWoD Roller <nr>=
	strcat( 
		u( f.registers.output-add, %2, %3, nostat ), 
		1 
	)



--

@@ skill -> skill.spec | untrained.spec | untrained
@@ this setup will allow 'untrained with specialty'
@@ it's up to the rest of the system to prevent this if necessary
@@ "untrained" does not remove from extened roll total
@@ specs always add to extended roll total

@@ q0: skill's name
@@ q1: skill's value 
@@ q2: specs name(s)
@@ q3: specs' value(s)

&f.stat-check.skill nWoD Roller <nr>=
	if( strmatch( %q3, skill.* ), 
		strcat( 
			setq( 0, first( %3, . )), 
			setq( 1, getstat( %0/%q0 )), 
			setq( 2, rest( %3, . )), 
			setq( 3, getstat( %0/%q2 )), 
			case( 1, 
@@ >> untrained skill (+ specs)
				u( f.stat-check.skill.untrained, %0, %q0, %q1, %q2, %q3, %2 ), 
				1, 

@@ >> skill (+ specs)
				u( f.stat-check.skill.trained, xxx ), 
				1, 

				#-1 Issue in Stat-Check Skill
			)
		)
	)

--

@@ if request was '- untrained skill', then result is probably positive
@@ strange, I know, but should work this way
@@ if not, here's the place to change it

@@ 0: sheet dbref
@@ 1: skill's name
@@ 2: skill's value (empty/0/error if 'untrained' )
@@ 3: specs name(s)
@@ 4: specs' value(s)
@@ 5: intended sign (usually +, but you never know)

@@ q6: untrained penalty
@@ q7: building dice to roll

&f.stat-check.skill.untrained nWoD Roller <nr>=
	not( %2 ), 
	strcat( 
		setq( 6, 
			case( 1, 
				hastag?( %1, physical.social, or ), 
				-1, 
				hastag?( %1, mental ), 
				-3, 
				-99
			)
		), 

		u( f.registers.dice-add, 
			setr( 7, ladd( %q6.%4, . ))
		), 
		u( f.registers.output-add, 
			[abs( %q7 )] 
			%(untrained %1[if( t( %3 ), .%3 )]%), 
			u( .sign, mul( %q7, strmatch( %5, - )))
		), 
		u( f.registers.extendednum-add, ladd( %4, . )), 

		1 
	)

--

@@ 0: sheet dbref
@@ 1: skill's name
@@ 2: skill's value (empty/0/error if 'untrained' )
@@ 3: specs name(s)
@@ 4: specs' value(s)
@@ 5: intended sign (usually +, but you never know)

&f.stat-check.skill.trained nWoD Roller <nr>=
	strcat( 
		u( f.registers.dice-add, ladd( %2.%4 ))
		u( f.registers.output-add, 
			%1[if( t( %3 ), .%3 )], 
			%5 
		), 
		u( f.registers.extendednum-add, ladd( %2.%4 )), 
		1 
	)

