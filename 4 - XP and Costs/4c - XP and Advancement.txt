/*
XP Advancement System

Performs and logs XP spends and gains.

Warning: This is a mess coded in a crunch.

-=-=-=-=-==-=---==-

* Give Passive XP: gain
* Be able to determine: not a spend/gain thing
* Be able to Award XP: gain
* Be able to spend XP: spend
* Be able to unaward XP: ungain
* Be able to unspend: unspend

-=-=-=-=-=-=-=-=-=-=-=-=

&_special.beats.<type> :: <total> -<spent>
&_special.earned_beats.<type> :: <amt earned this week>

Illegal characters: | and ` 

&d.xp_types xpas=normal player
&d.log_types xpas=gain spend freebie auto

-=-=-=-=-=-=-=-=-=-=-=

COMMANDS:
	xp : how much I got? (all types)
	xp <name> : how much they got?

√	xp/log [<name>]
√	xp/log <name>[/<type>]

√	xp/award <name>=<amt> for <reason> : give out dem generic goodies
√	xp/award <name>/<xp type>=<amt> for <reason> : give out dem specific goodies

√	xp/cost <stat>=<level>[/<xp type>] : how much it be costin'?
√	xp/cost <name>/<stat>=<level> : how much it be costin' for them?

√	xp/spend <stat>=<level> : spend some xps on some mad skillz
√	xp/spend <stat>=<level>/<xp type> : spend some specific xpz

√	xp/freebie <stat>=<level> for <reason> : Give <stat> spending xpz.
	(rewrite this and xp/spend and xp/cost to share redundant functions!)

	xp/convert <amt> [beats|xp] from <name> : Player xpz -> Normal xpz, yo.
	(<name> must be an alt of yours)

	xp/remove <name>=<amt> for <reason> : take some honey away
	xp/remove <name>/<xp type>=<amt> for <reason> : a specific kind of honey

	xp/unspend <name>=<amt> for <reason> : reduce stat by <amt>, give xp back
	xp/unspend <name>/<xp type>=<amt> for <reason> : bla bla bla




################################################################################
## THE SQL #####################################################################

DROP TABLE IF EXISTS xp_log;

--

CREATE TABLE IF NOT EXISTS xp_log ( 
	target_objid VARCHAR(255) NOT NULL, 
	target_name VARCHAR(255) NOT NULL, 

	enactor_objid VARCHAR(255) NOT NULL, 
	enactor_name VARCHAR(255) NOT NULL, 

	log_time TIMESTAMP NOT NULL DEFAULT NOW(), 

	xp_type VARCHAR(255) NOT NULL, 
	xp_amt DECIMAL(21,17) NOT NULL,

	trait_category VARCHAR(255), 
	trait_name VARCHAR(255), 
	trait_value VARCHAR(255), 

	action VARCHAR(255) NOT NULL, 
	reason VARCHAR(255) NOT NULL,

	PRIMARY KEY (target_objid, log_time) 
) ENGINE=INNODB; 




################################################################################
## THE OBJECT ##################################################################



================================================================================
== SETUP =======================================================================
*/

@create XP Advancement System <xpas>
@fo me=&d.xpas me=num( XP Advancement System <xpas> )
@set xpas=INHERIT SAFE

@fo me=&d.sfp xpas=[num( Stat Functions Prototype <sfp> )]
@fo me=&d.dd xpas=[num( Data Dictionary <dd> )]
@fo me=&d.xpcd xpas=[num( XP Cost Database <xpcd> )]
@fo me=&d.cg xpas=[num( GMC Chargen <cg> )]

@parent xpas=codp
&prefix.sql xpas=sql.
&prefix.validations xpas=validate.



/*
================================================================================
== COMMANDS ====================================================================

	xp : list all xp types (for <name>)
	xp/award : give out xp
	xp/remove : remove xp
	xp/spend : buy stats
	xp/check : output for 'spend' without buying stat/reducing xp


--------------------------------------------------------------------------------
-- XP : Show me things ---------------------------------------------------------

	xp [<name>] : list all xp types (for <name>)

*/


// FILLER FILLER FILLER FILLER FILLER FILLER FILLER 


/*
--------------------------------------------------------------------------------
-- xp/cost ---------------------------------------------------------------------

	xp/cost [<name>/]<stat>[=<value>]

a very temporary thing

*/

&c.xp/cost xpas=$xp/cost *:@pemit %#=[u( f.xp/cost, %0 )]


&c.xp/spend xpas=$xp/spend *:@pemit %#=[u( f.xp/spend, %0 )]


&c.xp/freebie xpas=$xp/freebie *:@pemit %#=[u( f.xp/freebie, %0 )]



/*
================================================================================
== SHORT FUNCTIONS =============================================================

--------------------------------------------------------------------------------
-- Short Functions -------------------------------------------------------------
*/

&.isapproved xpas=isapproved( %0, %1 )
&.value xpas=u( v( d.dd )/.value, %0, %1 )
&.msg xpas=ansi( h, <%0>, n, %b%1 )
&.plural xpas=if( eq( %0, 1 ), %0 %1, %0 %2 )
&.lmax xpas=lmax( %0 )


/*
--------------------------------------------------------------------------------
-- Object ID  ------------------------------------------------------------------

The unique identifier for an object, taken from Penn.
Outputs: <#dbref>:<creation time in secondss>

*/

&.objid xpas=localize( 
		if( t( setr( l, locate( %#, %0, * ))), 
			[num( %ql )]:[convtime( get( %ql/created ))], 
			#-1 NOT FOUND 
		)
	)



/* 
================================================================================
== SQL FUNCTIONS ===============================================================

Things related to SQL and converting to and from a table or database.


/*
--------------------------------------------------------------------------------
-- SQL Escape ------------------------------------------------------------------

I removed the nested edits, here. Rhost and TinyMUSH will choke here.

(... should ; also be escaped?)

*/

&f.sql.escape xpas=edit( %0, \\, \\\\\\, ', \\\\', ", \\\\", \%, \\\\\\\% )

/* -- test --

think u( xpas/f.sql.escape, lit(She said, "Oh my god!". \\ I said, "Relax; It's only a test."))


--------------------------------------------------------------------------------
-- HTML Escape -----------------------------------------------------------------

	(not needed at this time)
*/ 

&f.html.escape xpas=
	edit( edit( edit( edit( %0, &, &amp; ), %%, &#37; ), <, &lt; ), >, &gt; )


/*
--------------------------------------------------------------------------------
-- HTML Unescape ---------------------------------------------------------------

	(not needed at this time)
*/

&f.html.unescape xpas=
	edit( edit( edit( edit( %0, &#37;, %% ), &lt;, < ), &gt;, > ), &amp;, & )


/*
--------------------------------------------------------------------------------
-- Time: unix2sql --------------------------------------------------------------

0: secs.

*/

&f.time.unix2sql xpas=if( %0, timefmt( $Y-$m-$d $H:$M:$S $z, %0 ), none )

/* -- test --

think u( xpas/f.time.unix2sql, secs())

think sql( SELECT FROM_UNIXTIME( [secs()] ))
think timefmt( $Y-$m-$d $H:$M:$S $z, secs())


--------------------------------------------------------------------------------
-- Time: sql2unix --------------------------------------------------------------

0: SQL Datetime, string output.

*/

&f.time.sql2unix xpas=sql( SELECT UNIX_TIMESTAMP( '%0' ))

/* -- test --

think u( xpas/f.time.sql2unix, u( sja/f.time.unix2sql, secs() ))

think sql( SELECT UNIX_TIMESTAMP( '[u( xpas/f.time.unix2sql, secs() )]' ))
think secs()


--------------------------------------------------------------------------------
-- Transaction Begin/End -------------------------------------------------------

Technically an sql.* function, but easier to do this way.

*/

&f.transaction.begin xpas=
	strcat( 
		sql( START TRANSACTION ), 
		sql( SET autocommit = 0 )
	)

// --

&f.transaction.end xpas=
	strcat( 
		sql( COMMIT ), 
		sql( SET autocommit = 1 )
	)


/* 
--------------------------------------------------------------------------------
-- SQL: Add to XP Log ----------------------------------------------------------

0: target dbref
1: enactor dbref
2: xp type (probably 'normal')
3: xp amt
4: reason

*/

&sql.xp_log.add xpas=
	INSERT 
		INTO xp_log (
			target_objid, target_name, 
			enactor_objid, enactor_name, 
			xp_type, xp_amt, reason
		) 
		VALUES (
			'[u( .objid, %0 )]', '[name( %0 )]', 
			'[u( .objid, %1 )]', '[name( %1 )]', 
			'%2', %3, 
			'%4'
		)
			
			
/* 
--------------------------------------------------------------------------------
-- SQL: Add by Auto-Award System -----------------------------------------------

0: target dbref
1: enactor dbref
2: xp type (probably 'normal')
3: xp amt

*/

&sql.xp_log.auto-add xpas=
	INSERT 
		INTO xp_log (
			target_objid, target_name, 
			enactor_objid, enactor_name, 
			xp_type, xp_amt, reason
		) 
		VALUES (
			'[u( .objid, %0 )]', '[name( %0 )]', 
			'[u( .objid, %1 )]', 'Auto-Experience System', 
			'%2', %3, 'Daily Auto'
		)


/* 
--------------------------------------------------------------------------------
-- SQL: Get XP Log of One Type for One Character -------------------------------

A summary used for xp/log 

0: target dbref
1: xp type

*/

&sql.xp_log.type-character xpas=
	SELECT enactor_objid, enactor_name, log_time, xp_amt, reason 
	FROM xp_log 
	WHERE target_objid='[u( .objid, %0 )]' 
	AND xp_type='[lcstr( %1 )]'






/* 
################################################################################
## XP VIEWING ##################################################################

Important data:
	v( d.xp_types )
	v( d.beat-to-exp )
	get( <player>/_special.beats.<type> ) : <total> -<spent>



================================================================================
== Command: XP =================================================================

	xp : how much I got? (all types)
	xp <name> : how much they got? (all types)

*/

&c.xp.general xpas=$^\+?xp$:
	@assert cor( isapproved( %# ), isapproved( %#, chargen ))={ 
		@pemit %#=u( .msg, xp, You are not approved nor in chargen )
	}; 

	@pemit %#=
		strcat( 
			wheader( XP & Beats ), %r, 
			iter( v( d.xp_types ), 
				u( display.xp-and-beats.one-line, %#, %i0 ), 
				, %r 
			), %r, 
			wdivider(), %r, 

			if( isapproved( %# ), 
				u( display.approval-deets, %# )
			), %r, 

			wfooter()
		)

@set xpas/c.xp.general=regexp

// -- 

&c.xp.specific xpas=$^\+?xp (.+)$:
	think setr( p, pmatch( trim( %1 ))); 

	@assert cor( isstaff( %# ), strmatch( %#, %qp ))={ 
		@pemit %qp=u( .msg, xp, Staff or self only )
	}; 	

	@assert t( %qp )={ 
		@pemit %qp=u( .msg, xp, '[trim( %1 )]' not found )
	}; 	

	@assert cor( isapproved( %qp ), isapproved( %qp, chargen ))={ 
		@pemit %qp=u( .msg, xp, [name( %qp )] is not approved nor in chargen )
	}; 

	@pemit %#=
		strcat( 
			wheader( XP & Beats for [name( %qp )] ), %r, 
			iter( v( d.xp_types ), 
				u( display.xp-and-beats.one-line, %qp, %i0 ), 
				, %r 
			), %r, 
			wdivider(), %r, 

			if( isapproved( %qp ), 
				u( display.approval-deets, %qp )
			), 

			wfooter()
		)

@set xpas/c.xp.specific=regexp


/* 
--------------------------------------------------------------------------------
-- Display General XP Info -----------------------------------------------------

a: attribute
x: experiences
b: beats
e: earned

*/

&display.xp-and-beats.one-line xpas=
	strcat( 
		setq( a, get( %0/_special.beats.%1 )), 
		setq( c, ladd( %qa )), 
		setq( e, first( %qa )), 
		setq( s, rest( %qa )),

		ansi( h, titlestr( %1 )), :, %b, 
		Experience:, %b, floor( fdiv( %qc, v( d.beat-to-exp ))), %,%b, 
		Beats:, %b, mod( %qc, v( d.beat-to-exp )), %r, 
		%b- Earned:, %b, floor( fdiv( %qe, v( d.beat-to-exp ))), %r, 
		%b- Spent:, %b, abs( floor( fdiv( %qs, v( d.beat-to-exp )))) 
	)

think u( xpas/display.xp-and-beats.one-line, *vera, normal )

// --

&display.approval-deets xpas=
	localize( strcat( 
		setq( y, strmatch( %#, %0 )), 
		setq( n, name( %0 )), 
		setq( a, u( [v( d.cg )]/f.total_secs_approved, %0 )), 

		if( %qy, You have, %qn has ), %b, 
			been approved for, %b, 
			exptime( %qa ), 
			%r,
		if( %qy, You are, %qn is ), %b, 
			auto-gaining, %b, 
			u( f.auto.beats.weekly, %0 ), %b, 
			Normal Beats per week, %r, 
		if( %qy, You have, %qn has ), %b, 
			earned, %b, 
			default( %0/_special.beats_earned.normal, 0 ), %b, 
			out of, %b, 
			u( f.weekly_beats.max_earnable, %0 ), %b, 
			Normal Beats this week, %r, 
		It will be reset in, %b, 
			u( .plural, 
				sub( 7, u( f.day_in_approval_week, %0 )), 
				day, 
				days 
			), %r, 
	))

think u( xpas/display.approval-deets, pmatch( vera ))

/* 
================================================================================
== Command: xp/log =============================================================

	xp/log <name>[/<type>] -- staff only
	xp/log [<type>] -- players only
	xp/log[/<log type>] -- either/or

xp type: normal, player, cover, etc.
log type: gain, spend, freebie, auto

For now, shows the entire log of self or <name>. 
This system needs massively overhauled in the future.
Especially now that we're handing out other kinds of xps.

s: switch
o: non-switch input

p: raw target (kept for error reporting)
x: raw xp type (kept for error reporting)

t: processed target
e: processed xp type
g: processed log type (spend, gain, etc, from switch; null = all)

l: log sql results

*/

&c.xp/log xpas=$^\+?xp/log(.*)$:
	@assert not( isapproved( %#, guest ))={ 
		@pemit %#=u( .msg, xp/log, Players only )
	}; 

	think strcat( 

// grab switches, or not
		if( strmatch( %1, /* ), 
			strcat( 
				raw switches:, %b, setr( s, first( %1 )), %r, 
				raw everything else:, %b, setr( o, rest( %1 )), %r, 
			), 
			strcat( no switches:, %b, setr( o, %1 ), %r, )
		), 

// staff input is different than player input
// .. staff: <target>[/<type>]
// .. player: [<type>]
		if( isstaff( %# ), 
			strcat( 
				* STAFF *, %r, 
				raw target:, %b, setr( p, first( %qo, / )), %r, 
				raw type:, %b, setr( x, rest( %qo, / )), %r, 
			), 
			strcat( 
				* PLAYER *, %r, 
				raw target, %b, setr( p, %# ), %r, 
				raw type, %b, setr( x, %1 ), %r, 
			)
		), 

		processed target:, %b, setr( t, pmatch( trim( %qp ))), %r, 
		processed xp type:, %b, 
		setr( e, 
			grab( 
				|[edit( v( d.xp_types ), %b, | )], 
				trim( %qx* ), 
				| 
			)
		), %r, 
		xp type correction:, %b, 
		if( strmatch( %qx, ), setr( e, normal ), <no change> ), %r, 

		processed log type:, %b, 
		setr( g, 
			grab( 
				|[edit( v( d.log_types ), %b, | )], 
				rest( trim( %qs* ), / ), 
				| 
			)
		), %r, 
	); 

	@assert cor( strmatch( %#, %qp ), isstaff( %# ))={ 
		@pemit %#=u( .msg, xp/log, Self or staff only )
	}; 

	@assert t( %qt )={ 
		@pemit %#=u( .msg, xp/log, Target '[trim( %qp )]' not found )
	}; 

	@assert strlen( %qe )={ 
		@pemit %#=u( .msg, xp/log, 
			Experience type '[trim( %qx )]' not found 
		)
	}; 

	@assert cor( strlen( %qg ), strmatch( %qs, ))={ 
		@pemit %#=u( .msg, xp/log, 
			Log type '[rest(trim( %qs ), / )]' not found 
		)
	}; 

	think strcat( 
		Log:, setr( l, 
			iter( 
				sql( u( sql.select.type-character, %qt, %qe, %qg ), `, | ), 
				u( format.xp/log.one-line, %i0 ), 
				`, `
			)
		)
	); 

	@pemit %#=strcat( 
		wheader( 
			XP/Log[if( strlen( %qg ), /[capstr( %qg)] )] 
			for [name( %qt )] 
			%([capstr( %qe )]%) 
		), %r, 
		u( display.xp/log.header ), %r, 
		iter( %ql, u( display.xp/log.one-line, %i0 ), `, %r ), %r, 
		wfooter()
	)

// --

@set xpas/c.xp/log=regexp


/*
--------------------------------------------------------------------------------
-- Format One Line -------------------------------------------------------------
*/

&format.xp/log.one-line xpas=
	strcat( 
// who
		elements( %0, 2, | ), %b, %(, first( elements( %0, 1, | ), : ), %), |, 
// when
		elements( 
			convsecs( u( f.time.sql2unix, elements( %0, 3, | ))), 
			2 3 5 
		), |, 
// amt
		case( elements( %0, 5, | ), 
			spend, -, 
			freebie, - 
		), 
		trim( fdiv( floor( elements( %0, 4, | )), v( d.beat-to-exp )), l, 0 ), 
		|, 
// action: reason
		elements( %0, 5, | ), :%b, 
		elements( %0, 6, | )
	)


/*
--------------------------------------------------------------------------------
-- Display One Line ------------------------------------------------------------

Amt / Reason / Entered By / Date

Reason & Entered By are flexible to the viewer's screen width.

*/

&display.xp/log.header xpas=
	localize( strcat( 
		setq( w, sub( width( %# ), 80 )), 
		rjust( Exp, 5 ), %b%b, 
		ljust( Reason, add( 40, ceil( fdiv( %qw, 2 ))) ), %b, 
		ljust( Entered By, add( 20, floor( fdiv( %qw, 2 )))), %b,
		Date, %r, 
		wdivider()
	))

&display.xp/log.one-line xpas=
	localize( strcat( 
		setq( w, sub( width( %# ), 80 )), 
		rjust( elements( %0, 3, | ), 5 ), %b%b, 
		ljust( elements( %0, 4, | ), add( 40, ceil( fdiv( %qw, 2 ))) ), %b, 
		ljust( elements( %0, 1, | ), add( 20, floor( fdiv( %qw, 2 ))) ), %b,
		elements( %0, 2, | )
	))




/* 
################################################################################
## XP AWARDING #################################################################

Max 4 experience (20 beats) per week, aka:
	20 - u( f.auto.beats.weekly, <character> )

Store weekly earned on:
	&_special.beats_earned.normal

Valid award:
	lte( 
		add( <amt>, get( <character>/_special.beats_earned.normal )), 
		u( f.weekly_beats.max_earnable, <character> )
	)

'Chargen' people can be awarded anything.



================================================================================
== Command: xp/award ===========================================================

	xp/award <name>=<amt> for <reason> : give out dem generic goodies
	xp/award <name>/<xp type>=<amt> for <reason> : give out dem specific goodies

--

	n: name passed
	t: type passed (optional, default 'normal')
	a: amt passed
	r: reason passed

	d: character dbref
	x: current beats (for type) : _special.beats.<type>
	b: current week's earned beats : _special.beats_earned.<type>
	f: final weekly award attribute (for type)
	e: total weekly earnable (for type)

*/

&c.xp/award xpas=$^\+?xp/award(.+)$:
	@assert isstaff( %# )={ 
		@pemit %#=u( .msg, xp/award, Staff only )
	}; 

	think strcat( 
		name (w/type):, setr( n, first( %1, = )), %r, 
		type:, 
		setr( t, if( t( setr( t, trim( rest( %qn, / )))), %qt, normal )), %r, 
		name:, setr( n, trim( first( %qn, / ))), %r, 
		amt (w/reason):, setr( a, rest( %1, = )), %r, 
		reason:, setr( r, trim( rest( %qa, %bfor%b ))), %r, 
		amt:, setr( a, trim( first( %qa, %bfor%b )))
	); 

	@assert hastype( setr( p, pmatch( %qn )), PLAYER )={ 
		@pemit %#=u( .msg, xp/award, Could not find '%qn' )
	}; 

	@assert cor( isapproved( %qp ), isapproved( %qp, chargen ))={ 
		@pemit %#=u( .msg, 
			xp/award, 
			'[name( %qp )]' is not approved nor in chargen 
		)
	}; 

	@assert hastype( setr( p, pmatch( %qn )), PLAYER )={ 
		@pemit %#=u( .msg, xp/award, Could not find '%qn' )
	}; 

	@assert isint( %qa )={ 
		@pemit %#=u( .msg, xp/award, Award must be an integer )
	}; 

	@assert strlen( %qr )={ 
		@pemit %#=u( .msg, xp/award, Must include reason )
	}; 

	@break cor( strmatch( %qr, *|* ), strmatch( %qr, *`* ))={ 
		@pemit %#=u( .msg, xp/award, May not use | or ` in reason )
	}; 

	@assert t( match( v( d.xp_types ), %qt ))={ 
		@pemit %#=u( .msg, xp/award, I can't find the '%qt' type )
	}; 

	think strcat( 
		experience:, setr( x, get( %qp/_special.beats.%qt )), %r, 
		beats earned:, setr( b, get( %qp/_special.beats_earned.%qt )), %r, 
		final award attribute:, setr( f, add( %qa, %qb )), %r, 
		total weekly earnable:, setr( e, u( f.weekly_beats.max_earnable, %qp ))
	); 

	@assert cor( lte( %qf, %qe ), isapproved( %qp, chargen ))={
		@pemit %#=u( .msg, 
			xp/award, 
			'[name( %qp )]' cannot take that many %qt beats. 
			They can only take '[floor( sub( %qe, %qb ))]' more beats 
			for the rest of their week.
		)
	}; 

// add to '_special.beats.<type>'
	@set/quiet %qp=
		_special.beats.%qt:
		[add( first( %qx ), %qa )] [rest( %qx )];

// if approved, add to '_special.beats_earned.<type>'
	@set/quiet %qp=
		_special.beats_earned.%qt:
		[if( isapproved( %qp ), %qf )]; 

// add to xp_log (sql)

	think strcat( 
		tranaction begin, u( f.transaction.begin ), %r, 
		sanitized reason:, setr( s, u( f.sql.escape, %qr )), %r, 
		add to xp_log:, sql( u( sql.insert.award, %qp, %#, %qt, %qa, %qs )), %r, 
		tranaction end, u( f.transaction.end )
	); 

// notify enactor and target
	@pemit %#=u( .msg, 
		xp/award, 
		You have awarded '[name( %qp )]' 
		[u( .plural, %qa, Beat, Beats )] 
		[if( not( strmatch( %qt, normal )), %(%qt%)%b )]
		for '%qr' 
	); 

	@pemit %qp=u( .msg, 
		xp/award, 
		[moniker( %# )] has just awarded you 
		[u( .plural, %qa, Beat, Beats )] 
		[if( not( strmatch( %qt, normal )), %(%qt%)%b )]
		for '%qr' 
	); 


// -- 

@set xpas/c.xp/award=regexp




/* 
################################################################################
## XP PURCHASING ###############################################################



================================================================================
== SETUP =======================================================================
*/

&d.beat-to-exp xpas=5

&d.xp_types xpas=normal player
&d.log_types xpas=gain spend freebie auto

&default.special.xp.normal dd=0 0


/*
--------------------------------------------------------------------------------
-- Restricted Stats ------------------------------------------------------------
*/

&d.restricted.types xpas=iter( lattr( %!/d.restricted.types.*, u( %i0 )))
&d.restricted.types.default xpas=bio

&d.restricted.stats xpas=iter( lattr( %!/d.restricted.stats.*, u( %i0 )))
&d.restricted.stats.default xpas=advantage.integrity merit.status_(*) 

/* 
Eldritch is also restricting all supernatural merits.
This includes human-only merits.

If you'd like to use this, run the code below:

&d.restricted.stats xpas=
	cat( 
		iter( lattr( %!/d.restricted.stats.*, u( %i0 ))), 
		edit( 
			filter( 
				v( d.sfp )/f.hastag?.workhorse, 
				lattr( v( d.dd )/merit.* ), , , 
				get( v( d.dd )/bio.template ) 
			), 
			%(%), %(*%) 
		)
	)

*/


/* CHECK XP COST

--------------------------------------------------------------------------------
-- XP Cost Calculator ----------------------------------------------------------

Brings the formulas and the formula finder together.

0: dbref of sheet (qw)
1: stat-from (Even if it's not used) (qt)
2: stat-to (qv)
3: statpath (qs)

s: statpath without instance
v: main.value.list
f: formula's attribute name

*/

&f.cost.calculator xpas=
	localize( strcat( 
		setq( s, u( v( d.sfp )/f.statpath-without-instance, trim( %3, l, _ ))), 
		setq( f, u( f.formula_finder, %qs, %0 )), 
		setq( v, first( get( v( d.dd )/%qs ), | )), 

		if( t( %qf ), 
			u( 
				v( d.xpcd )/%qf, 
				%0, %1, %2, rest( %3, . ), %qv 
			), 

			%qf
		)
	))


/*
--------------------------------------------------------------------------------
-- XP Formula Finder -----------------------------------------------------------

This code is meant to find out which of the xp.<blah> function to look up for any given statpath. It only finds the name.

>>> XP FORMULAS ARE STORED ON THE XPCD <<<

Below is the ?.?.?[~<template>] finder test.

--

&xp.skill.?.?~[get( %#/_bio.template)] xpcd=1

think 
	[setq( z, get( %#/_bio.template ))]
	[setr( t, setr( s, skill.academics.history ))] --> 
	[setr( n, lnum( words( %qs, . ), 2 ))] --> 
	[setr( n, iter( %qn, setr( t, replace( %qt, %i0, ?, . ))))] --> 
	[setr( n, [iter( %qn, %i0~%qz )] %qn )] --> 
	[first( filter( xpas/fil.formula_finder, %qn, , , xp ))]

&xp.skill.?.?~[get( %#/_bio.template)] xpcd=

--

0: dd.statpath_(without instance)
1: dbref of sheet

t: sheet template

s: temp statpaths for the ? wildcard
x: temp statpaths for the degrading search

*/

&f.formula_finder xpas=
	localize( strcat( 

// set registers
		setq( t, get( %1/_bio.template )), 

		setq( s, %0 ), 
		setq( s, 
			filter( fil.formula_finder, 
				iter( 
					lnum( words( %0, . ), 2 ), 
					setr( s, replace( %qs, %i0, ?, . ))
				), , ,xp
			)
		), 
		setq( s, 
			cat( 
				iter( %qs, %i0~%qt ), 
				%qs
			)
		), 
		setq( s, filter( fil.formula_finder, %qs, , , xp )), 

		setq( x, %0 ), 
		setq( x, 
			filter( fil.formula_finder, 
				iter( 
					lnum( words( %0, . ), 1 ), 
					setr( x, ldelete( %qx, %i0, . ))
				), , , xp
			)
		), 
		setq( x, 
			cat( 
				iter( %qx, %i0~%qt ), 
				%qx
			)
		), 
		setq( x, filter( fil.formula_finder, %qx, , , xp )), 

// TEST
		case( 1, 

// xp.<statpath>~<template>
			t( filter( fil.formula_finder, %0~%qt, , , xp )), 
			xp.%0~%qt, 

// xp.<statpath>
			t( filter( fil.formula_finder, %0, , , xp )), 
			xp.%0, 

// xp.<type>.?[~<template>]
			t( %qs ), 
			xp.[first( %qs )], 

// xp.<type>[~<template>], like above but without the ? involved
			t( %qx ), 
			xp.[first( %qx )], 

// else: error
			#-1 No Experience costs found 
		)
	))

// --

&fil.formula_finder xpas=hasattr( v( d.xpcd ), %1.%0 )

// --
// &xp.skill.?.?~[get( %#/_bio.template)] xpcd=1
// think u( xpas/f.formula_finder, %#, skill.academics.history )
// &xp.skill.?.?~[get( %#/_bio.template)] xpcd=


/*
--------------------------------------------------------------------------------
-- XP/COST ---------------------------------------------------------------------

Cost (and therefore Spend) does a cheat I use in other places: Its support 
functions pull directly from the set registers, instead of passing them. This 
may cause problems in the future.

0: [<player>/]<stat>[=<value>]
p: player dbref
n: stat name
v: requested value (new)

w: where's the sheet
s: stat path
t: trait's value (current, from the sheet)
c: cost

e: error message, if any
x: current 'beats' attribute

*/

&f.xp/cost xpas=
	strcat( 

// break %0 down to p, n, v
		setq( p, first( %0, = )), 
		setq( v, rest( %0, = )), 
		setq( n, rest( %qp, / )), 
		setq( p, first( %qp, / )), 
		if( not( t( %qn )), 
			strcat( setq( n, %qp ), setq( p, %# )),
			setq( p, pmatch( %qp ))
		), 

// get sheet location, statpath
		setq( w, ulocal( v( d.sfp )/f.find-sheet, %qp )),
		setq( s, ulocal( v( d.sfp )/f.statpath.workhorse, %qn, %qp )), 

// current value, next value, estimated cost
		setq( t, ulocal( .value, %qw, %qs )), 
		if( 
			not( t( %qv )), 
			setq( v, ulocal( f.stat.next_rank, %qw, _%qs ))
		), 
		setq( c, ulocal( f.cost.calculator, %qw, %qt, %qv, %qs )), 

// current 'xp' attribute
		setq( x, get( %qw/_special.beats.normal )), 

		case( 1, 
			t( setr( e, ulocal( validate.player, %qp, %qw, 1 ))), 
			ulocal( .msg, xp/cost, %qe ), 

			t( setr( e, ulocal( validate.stat, %qw, %qs, %qt, %qv ))), 
			ulocal( .msg, xp/cost, %qe ), 

			t( setr( e, ulocal( validate.value, %qs, %qt, %qv ))), 
			ulocal( .msg, xp/cost, %qe ), 

			t( setr( e, ulocal( validate.cost, %qc ))), 
			ulocal( .msg, xp/cost, %qe ), 

			ulocal( .msg, xp/cost, 
				ulocal( display.xp/cost, %qp, %qn, %qs, %qv, %qt )
			)

		)
	)

// -- test --

think u( xpas/f.xp/cost, strength )
think u( xpas/f.xp/cost, *vera/strength=1 )

/*
--------------------------------------------------------------------------------
-- Display: XP/Cost ------------------------------------------------------------

0: player dbref (qp)
1: stat name as entered (qn)
2: statpath (qs)
3: requested value (qv)
4: trait's current value (qt)

e: error check results
f: other error check results

*/

&display.xp/cost xpas=
	strcat( 
		The cost, %b,  

		if( not( strmatch( %#, %0 )), 
			cat( for, name( %0 ), )
		), 

		case( 
			u( v( d.sfp )/f.get-class, %2 ), 

			list, 
			strcat( 
				to add %3, %b, 
				%(, u( u( d.dd )/.class_translate_list, %2, %3 ), %), 
				%b, to, %b, 
				statname( %0/%1 )
			), 

			flag, 
			strcat( 
				to add, %b', statname( %0/%1 ), '%b, 
				%(, %3, %)
			), 

			cat( 
				to raise, 
				statname( %0/%1 ), 
				from, 
				if( strlen( %4 ), %4, 0 ), 
				to %3 
			)
		), %b, 

		is %qc Experience., 

// .. can't afford?
		setq( e, u( validate.spend, %qc, %qx )), 
		setq( f, u( validate.restricted, %qs, %qv )), 
		case( 1, 
			cand( %qe, %qf ), %b%(%qe%, %qf.%), 
			t( %qe ), %b%(%qe.%), 
			t( %qf ), %b%(%qf.%) 
		)
	)


/*
--------------------------------------------------------------------------------
-- XP Next Stat Rank -----------------------------------------------------------

For our next trick, we'll take <sheet> and <stat> and return the next logical 
value for that stat. For instance, a skill from 0 to 1, Stunning Looks from 2 
to 4. It will return #-1 should the person be at the top of the list, as well 
as other errors.

If a stat whose value set is # can always be raised.

Needs to handle specialties properly. The XP cost calculator does, too.

0: sheet dbref
1: _sheet.statpath_(with_instance)

d: dd statpath, without instance
c: stat class
s: value of stat on sheet
v: valid values
n: next rank, if applicable
*/

&f.stat.next_rank xpas=
	localize( strcat( 
		setq( d, 
			ulocal( v( d.sfp )/f.statpath-without-instance, trim( %1, l, _ ))
		), 
		setq( s, first( udefault( %0/%1, 0 ), . )), 
		setq( v, first( u( v( d.dd )/%qd ), | )), 
		setq( n, extract( %qv, inc( match( %qv, %qs, . )), 1, . )), 

		case( 1, 
			strmatch( %qv, # ), inc( %qs ), 
			strmatch( %1, _skill.*.* ), inc( %qs ), 
			not( t( %qn )), #-1 That stat can't go any higher, 
			gt( %qs, last( %qv, . )),  #-1 Stat Already Above Max Level, 
			%qn 
		 )
	))


/*
================================================================================
== XP/SPEND ====================================================================

Extended form of 'xp/cost'

	xp/spend [<player>/]<stat>[=<value>[/<xp type>]]

	xp/spend <stat>
	xp/spend <stat>=<value>
	xp/spend <stat>=<value>/<xp type>
	xp/spend <stat>=<value>/<xp type> <amt>/<xp type> <amt>/<xp type> <amt>
	xp/spend/<xp_type>:<amt>/<xp_type>:<amt> <stat>=<value>

--

0: [<player>/]<stat>[=<value>[/<xp type>]]
p: player dbref
n: stat name
v: requested value (new)

w: where's the sheet
s: stat path
t: trait's value (current, from the sheet)
c: cost

e: error message, if any
x: current 'beats' attribute

n: statname

*/

&f.xp/spend xpas=
	strcat( 

// break %0 down to p, n, v
		setq( p, first( %0, = )), 
		setq( v, rest( %0, = )), 
		setq( n, rest( %qp, / )), 
		setq( p, first( %qp, / )), 
		if( not( t( %qn )), 
			strcat( setq( n, %qp ), setq( p, %# )),
			setq( p, pmatch( %qp ))
		), 

// get sheet location, statpath
		setq( w, ulocal( v( d.sfp )/f.find-sheet, %qp )),
		setq( s, ulocal( v( d.sfp )/f.statpath.workhorse, %qn, %qp )), 

// current value, next value, estimated cost
		setq( t, ulocal( .value, %qw, %qs )), 
		if( 
			not( t( %qv )), 
			setq( v, ulocal( f.stat.next_rank, %qw, _%qs ))
		), 
		setq( c, ulocal( f.cost.calculator, %qw, %qt, %qv, %qs )), 

// current 'xp' attribute
		setq( x, get( %qw/_special.beats.normal )), 

		case( 1, 

// TEMPORARY: STAFF-ONLY
			not( isstaff( %# )), 
			u( .msg, xp/spend, For now%, please use 'req/xp <title>=<spend>' ), 

// normal checks
			t( setr( e, ulocal( validate.player, %qp, %qw, 1 ))), 
			u( .msg, xp/spend, %qe ), 

			t( setr( e, ulocal( validate.stat, %qw, %qs, %qt, %qv ))), 
			u( .msg, xp/spend, %qe ), 

			t( setr( e, ulocal( validate.value, %qs, %qt, %qv ))), 
			u( .msg, xp/spend, %qe ), 

			t( setr( e, ulocal( validate.cost, %qc ))), 
			u( .msg, xp/spend, %qe ), 

			t( setr( e, ulocal( validate.spend, %qc, %qx ))), 
			u( .msg, xp/spend, %qe ), 

			t( setr( e, ulocal( validate.restricted, %qs, %qv ))), 
			u( .msg, xp/spend, %qe ), 


// spend 1: log to sql and check - stop if failed
			strmatch( 
				setr( e, 
					sql( u( sql.insert.spend, 
						%qp, %#, normal, mul( %qc, v( d.beat-to-exp )), 
						u( f.sql.escape, %qs ), 
						u( f.sql.escape, 
							[statname( %qp/%qn )] '%qt' -> '%qv' 
						), 
						%qv 
					))
				), 
				#-* 
			), 
			u( .msg, xp/spend, XP log entry failed. Spend not processed. ), 

// spend 2: run setstat and check - stop if failed
			strmatch( 
				setr( e, 
					ulocal( v( d.sfp )/f.setstat.workhorse, %qw, %qs, %qv )
				), 
				#-* 
			), 
			u( .msg, xp/spend, Error from Setstat: %qe ), 

			strcat( 

// spend 3: adjust xp and check - process even if failed
				setq( e, set( %qw, 
					_special.beats.normal:
					[first( %qx )] 
					[sub( rest( %qx ), mul( %qc, v( d.beat-to-exp )))] 
				)), 
				if( strmatch( %qe, #-* ), 
					u( .msg, xp/spend, 
						Error while setting new xp: %qe %r
						%(Original XP attribute: %qx%) 
					)
				), 

// spend 4: message to enactor
				setq( n, statname( %qp/%qn )), 
				u( .msg, xp/spend, 
					strcat( 
						if( strmatch( %qp, %# ), 
							Your, 
							[name( %qp )]'s
						), %b, 
						%qn, %b, 
						has been set, 
						case( u( v( d.sfp )/f.get-class, %qs ), 
							list, , 
							%bto '%qv', 
						), %b, 
						for %qc Experience.
					)
				), 
			)
		)
	)



/*
================================================================================
== XP/FREEBIE ==================================================================

	xp/freebie <player>/<stat>[=<value>] for <reason>

This is 'xp/spend' without spending any xp.

This is important, for now, for some spends that grant other items, 
such as Professional Training.

&testreg me=(.+)/(.+?)(=(.+))? for (.+)
think regmatchi( <player>/<stat>=<value> for <reason>, v( testreg ), -1 p s -1 v r 5 ) -- [iter( p s v r, r( %i0 ), , %b--%b )]

think regmatchi( <player>/<stat> for <reason>, v( testreg ), -1 p n -1 v r ) -- [iter( p n v r, r( %i0 ), , %b--%b )]

*/

&d.regex.freebie xpas=(.+)/(.+?)(=(.+))? for (.+)

// -- 

&f.xp/freebie xpas=
	strcat( 

// break %0 down to <player>, <name of stat>, [<value>], <reason>
		setq( 0, regmatchi( %0, v( d.regex.freebie ), -1 p n -1 v r )), 
		setq( p, pmatch( %qp )), 

// get sheet location, statpath
		setq( w, ulocal( v( d.sfp )/f.find-sheet, %qp )),
		setq( s, ulocal( v( d.sfp )/f.statpath.workhorse, %qn, %qp )), 

// current value, next value
		setq( t, ulocal( .value, %qw, %qs )), 
		if( not( %qv ), 
			setq( v, ulocal( f.stat.next_rank, %qw, _%qs ))
		), 

		case( 1, 
			not( isstaff( %# )), 
			u( .msg, xp/freebie, Staff only ), 

// normal checks
			not( strlen( %qr )), 
			u( .msg, xp/freebie, Must provide a reason this is free ), 

			t( setr( e, ulocal( validate.player, %qp, %qw, 1 ))), 
			u( .msg, xp/freebie, %qe ), 

			t( setr( e, ulocal( validate.stat, %qw, %qs, %qt, %qv ))), 
			u( .msg, xp/freebie, %qe ), 

			t( setr( e, ulocal( validate.value, %qs, %qt, %qv ))), 
			u( .msg, xp/freebie, %qe ), 

			t( setr( e, ulocal( validate.restricted, %qs, %qv ))), 
			u( .msg, xp/freebie, %qe ), 

// spend 1: log to sql and check - stop if failed
			strmatch( 
				setr( e, 
					sql( u( sql.insert.spend, 
						%qp, %#, normal, 0, u( f.sql.escape, %qs ), 
						u( f.sql.escape, 
							[statname( %qp/%qn )] '%qt' -> '%qv' 
							for reason '%qr' 
						), 
						%qv 
					))
				), 
				#-* 
			), 
			u( .msg, xp/freebie, XP log entry failed. Spend not processed. ), 

// spend 2: run setstat and check - stop if failed
			strmatch( 
				setr( e, 
					ulocal( v( d.sfp )/f.setstat.workhorse, %qw, %qs, %qv )
				), 
				#-* 
			), 
			u( .msg, xp/freebie, Error from Setstat: %qe ), 

			strcat( 

// spend 3: ignored; we're not spending xp

// spend 4: message to enactor
				setq( n, statname( %qp/%qn )), 
				u( .msg, xp/freebie, 
					strcat( 
						if( strmatch( %qp, %# ), 
							Your, 
							[name( %qp )]'s
						), %b, 
						%qn, %b, 
						has been set to '%qv' for Free 
						because '%qr'
					)
				), 
			)
		)
	)



/*
================================================================================
== XP/CONVERT ==================================================================

An unusual fringe case. Rather than creating a system to dump Player Experience 
on an object shared by alts, each character object stores their own Player 
Experience and these beats can be converted into spendable Normal Experience 
on an alt object.

Requires '9e - Alt Registration.txt'.

	xp/convert <number> from <name>
	xp/convert all from <name>
	xp/convert <number> beats|xp|experience from <name>

*/

@fo me=&d.ars xpas=[search( name=Alt Registration <ars> )]

// -- 

/*
	a: amt (in beats)
	t: type (beats|experience|xp)

	n: target name
	d: target dbref
	o: target objid
	x: target's _special.beats.player

	l: enactor's _special.beats.normal

	r: 'reason' for xp_log
*/

&c.xp/convert [v( d.xpas )]=$^\+?xp/convert (.+) from (.+)$:
	think strcat( 
		** initial registers **, %r, 
		-- amt/type --, %r, 
		type:, %b, setr( t, grab( beats|experience|xp, [rest( %1 )]*, | )), %r, 
		amt:, %b, 
			setr( a, 
				case( %qt, 
					beats, first( %1 ), 
					experience, mul( first( %1 ), v( d.beat-to-exp )), 
					xp, mul( first( %1 ), v( d.beat-to-exp )), 
					0 
				)
			), 
		%r, 
		-- target --, %r, 
		name:, %b, setr( n, trim( %2 )), %r, 
		dbref:, %b, setr( d, if( strmatch( %qn, me ), %#, pmatch( %qn ))), %r, 
		objid:, %b, setr( o, u( .objid, %qd )), %r, 
		player xp:, %b, setr( x, get( %qd/_special.beats.player )), %r, 
		-- enactor --, %r, 
		normal xp:, %b, setr( l, get( %#/_special.beats.normal )), %r, 
	); 

	@assert t( %qo )={ 
		@pemit %#=u( .msg, xp/convert, Character '%qn' not found. ) 
	}; 

	@assert strlen( %qt )={ 
		@pemit %#=u( .msg, xp/convert, 
			If you're going to enter a type%, it must be 'beats'%, 
			'experience'%, or 'xp'. Leave blank for 'beats'. 
		) 
	}; 

	@assert cand( isint( %qa ), gt( %qa, 0 ))={ 
		@pemit %#=u( .msg, xp/convert, 
			Amount to transfer must be a non-zero integer 
		) 
	}; 

	@assert u( v( d.ars )/f.has-alt, %#, %qo )={ 
		@pemit %#=u( .msg, xp/convert, 
			'[name( %qd )]' is not an alt of yours. 
			If [subj( %qd )] should be%, see: +help alts 
		) 
	}; 

	@assert gte( ladd( %qx ), %qa )={ 
		@pemit %#=u( .msg, xp/convert, 
			[name( %qd )] doesn't have that much Player Experience 
		)
	}; 

// 'spend' from target's Player Experience
	@set/quiet %qd=
		_special.beats.player:[first( %qx )] [sub( rest( %qx ), %qa )]; 

	think strcat( 
		** spend player experience **, %r, 
		reason:, setr( r, Converted Player Experience to %N (%#) ), %r, 
		-- tranaction begin --, u( f.transaction.begin ), %r, 
		sanitized reason:, setr( r, u( f.sql.escape, %qr )), %r, 
/*
0: target dbref
1: enactor dbref (may be the same)
2: xp type (probably 'normal')
3: xp amt
4: full statpath (with instance)
5: reason (probably 'statname old -> new') 
6: value set/added
*/
		add to xp_log:, 
			sql( u( sql.insert.spend, %qd, %#, player, %qa, , %qr )), %r, 
	); 

// 'gain' to enactor's Normal Experience
	@set/quiet %#=
		_special.beats.normal:[add( first( %ql ), %qa )] [rest( %ql )];

	think strcat( 
		** gain normal experience **, %r, 
		reason:, 
			setr( r, Converted Player Experience from [name( %qd )] (%qd) ), %r, 
		sanitized reason:, setr( r, u( f.sql.escape, %qr )), %r, 
/*
0: target dbref
1: enactor dbref
2: xp type (probably 'normal')
3: xp amt
4: reason
*/
		add to xp_log:, 
			sql( u( sql.insert.award, %#, %#, normal, %qa, %qr )), %r, 
		-- tranaction end --, u( f.transaction.end ), %r 
	); 

	@pemit %#=u( .msg, xp/convert, 
		Converted %qa beats 
		from [name( %qd )]'s Player Experience 
		to [name( %# )]'s Normal Experience 
	); 

// -- 

@set xpas/c.xp/convert=regex

/* CURRENT OUTPUT 

Jared says, “Whoa, major complicated.”
Jared peers.
You say, “Let me push the current pretty code to github”
** initial registers **
-- amt/type --
type: beats
amt: 2
-- target --
name: me
dbref: #7
objid: #7:1412477070
player xp: 50 -22
-- enactor --
normal xp: 72 -50

** spend player experience **
reason:Converted Player Experience to Thenomain (#7)
-- tranaction begin --
sanitized reason:Converted Player Experience to Thenomain (#7)
add to xp_log:

** gain normal experience **
reason:Converted Player Experience from Thenomain (#7)
sanitized reason:Converted Player Experience from Thenomain (#7)
add to xp_log:#-1 QUERY ERROR
-- tranaction end --

<xp/convert> Converted 2 beats from Thenomain's Player Experience to Thenomain's Normal Experience

*** WORKING OUTPUT: From Vera to Thenomain ***

add to xp_log:#-1 QUERY ERROR
-- tranaction end --

<xp/convert> Converted 2 beats from Thenomain's Player Experience to Thenomain's Normal Experience
Thenomain adds the working Alt output to the github. Sec.
** initial registers **
-- amt/type --
type: beats
amt: 2
-- target --
name: vera
dbref: #300
objid: #300:1422406673
player xp: 50 -2
-- enactor --
normal xp: 78 -50

** spend player experience **
reason:Converted Player Experience to Thenomain (#7)
-- tranaction begin --
sanitized reason:Converted Player Experience to Thenomain (#7)
add to xp_log:

** gain normal experience **
reason:Converted Player Experience from Vera (#300)
sanitized reason:Converted Player Experience from Vera (#300)
add to xp_log:
-- tranaction end --

<xp/convert> Converted 2 beats from Vera's Player Experience to Thenomain's Normal Experience




*/

/*
================================================================================
== VALIDATIONS =================================================================


--------------------------------------------------------------------------------
-- Validate: Player ------------------------------------------------------------

Everything there is to validate about a player. Sheet, approved, staff status, etc. Staff can check or set non-approved players.

0: character dbref (qp)
1: sheet dbref (qw)
2: 1 if we're just checking; allow unapproved players to check

*/

&validate.player xpas=
	case( 0, 
		cor( isstaff( %# ), match( %0, %# )), 
		Yourself only, 

		t( %1 ), 
		Could not find a sheet, 

		cor( %2, isapproved( %0, approved ), isstaff( %# )), 
		Must be approved for play to spend Experience 
	)


/*
--------------------------------------------------------------------------------
-- Validate: Stat --------------------------------------------------------------

Uses 'f.statcheck' for almost all of it.

0: sheet dbref (qw)
1: statpath (qs)
2: trait's current sheet value (qt)
3: requested value (new) (qv)

v: chargen's stat validation

*/

&validate.stat xpas=
	localize( strcat( 

		setq( v, 
			u( v( d.cg )/f.statcheck, 
				%0, _%1, 
				case( 
					u( v( d.sfp )/f.get-class, %1 ), 
					numeric, sub( %3, %2 ), 
					%3 
				)
			)
		), 

		case( 0, 
			t( %1 ), Stat not found, 
			not( strmatch( %3, #-* )), capstr( lcstr( rest( %3 ))), 

			cor( t( first( %qv, . )), strmatch( %3, )), 
			capstr( lcstr( rest( first( %qv, . )))), 

			t( elements( %qv, 2, . )), 
			Can't set the stat outside character generation, 

			t( elements( %qv, 3, . )), 
			Stat cannot be taken by your template, 

			t( elements(%qv, 4, . )), 
			rest( elements( %qv, 4, . ))
		)
	))


/*
--------------------------------------------------------------------------------
-- Validate: Cost --------------------------------------------------------------

0: calculated cost (qc)

*/

&validate.cost xpas=
	case( 1, 
		cand( isstaff( %# ), not( t( %0 ))), 
		This stat has no Experience cost and must be set using 'stat/set', 

		not( %0 ), 
		This stat has no Experience cost and must be set by a staffer 
	)


/*
--------------------------------------------------------------------------------
-- Validate: Value -------------------------------------------------------------


0: full.statpath_(with_instance), %qs
1: trait's value (current, from sheet), %qt
2: requested value (new), %qv

c: stat class
returns: <null> if ok, otherwise error message

*/

&validate.value xpas=
	localize( strcat( 
		setq( c, ulocal( v( d.sfp )/f.get-class, %0 )), 
		setq( v, lcstr( first( get( v( d.dd )/%0 ), | ))), 

		case( %qc, 
			list, 
			case( 0, 
				t( %2 ), 
				capstr( lcstr( rest( %2 ))), 

				eq( 
					words( setinter( %qv, lcstr( %2 ), . ), . ), 
					words( %2, . )
				), 
				Value not in the list of values I can set, 

				not( match( %1, %2, . )), 
				You already have the stat at that level
			), 

			numeric, 
			case( 0, 
				t( %2 ), 
				capstr( lcstr( rest( %2 ))), 

				isint( %2 ), 
				Raise must be numeric, 

				gt( %2, %1 ), 
				Stat must be raised
			), 

			string, 
			Cannot raise string stats, 

			flag, 
			@@( all flags should be okay ),

			Uncaptured stat class type in 'validate.value' 

		)
	))

/*
--------------------------------------------------------------------------------
-- Validate: Spend -------------------------------------------------------------

After we've validated everything else, can the person afford it?

0: cost (qc), in experience
1: experience attribute (qx), in beats

*/

&validate.spend xpas=
	if( 
		gt( %0, fdiv( ladd( %1 ), v( d.beat-to-exp ))), 
		Not enough Experience 
	)


/*
--------------------------------------------------------------------------------
-- Validate: Restricted --------------------------------------------------------

Returns error if stat is "restricted", meaning that only staff may 
buy it for them.

ELDRITCH HOUSE-RULE: Numeric traits of 4+ are also restricted

0: stat path (qs)
1: requested value (qv)

*/

&validate.restricted xpas=
	localize(
		case( 1, 
			isstaff( %# ), @@( ignore entirely ), 

			t( match( u( d.restricted-types ), first( %0, . ))), 
			Stats of this type must be purchased for you by a staffer, 

			t( match( u( d.restricted-stats ), %0 )), 
			This stat must be purchased for you by a staffer, 

/* eldritch house rule; uncomment if you'd like this
			cand( 
				strmatch( u( v( d.sfp )/f.get-class, %0 ), numeric ), 
				gte( %1, 4 )
			), 
			Stats 4+ must be set by staff 
*/
		)
	)




/*
################################################################################
## AUTO XP GAINING #############################################################


&d.one-day xpas=86400
&d.one-week xpas=604800
&d.beats.max_weekly xpas=20
&d.period.weeks xpas=26


================================================================================
== AUTO ========================================================================
*/


// Week's End calculation: 
// Every 7th day after most recent Approval, reset the 'earned beats this week'.

&f.at_weeks_end? xpas=eq( u( f.day_in_approval_week, %0 ), 0 )

&f.day_in_approval_week xpas=
	localize( strcat( 
		setq( a, grab( revwords( get( %0/_approval.log ), | ), approved:*, | )), 
		setq( a, elements( %qa, 2, : )), 
		mod( idiv( sub( secs( ), %qa ), v( d.one-day )), 7 )
	))



// which << 26-week >> period is the character's approval time in? 
// start at 1

&f.current_period xpas=
	ceil( fdiv( 
		u( [v( d.cg )]/f.total_secs_approved, %0 ), 
		mul( v( d.one-week ), inc( v( d.period.weeks )))
	))



&f.auto.beats.weekly xpas=
	case( u( f.current_period, %0 ), 
		0, 0, 
		1, 10, 
		2, 5, 
		3, 3, 
		1 
	)
	

&f.auto.beats.daily xpas=
	fdiv( u( f.auto.beats.weekly, %0 ), 7 )


// max beats per week = 20 - auto beats per week
&f.weekly_beats.max_earnable xpas=
	sub( v( d.beats.max_weekly ), u( f.auto.beats.weekly, %0 ))


// Yup! That works! That's the setup stuff. Now we can calculate 
// everything we need to for xp awards, et al.




&f.approved_characters xpas=
	search( eplayer=cand( isapproved( ## ),  not( isstaff( ## ))))


	
/*

@daily xpas=
	@pemit *thenomain=XPAS: Triggering Daily
	@trigger %!/trig.daily.xp; 
	@trigger %!/trig.weekly.reset; 

*/


/* 
================================================================================
== AUTO: ADD DAILY XP ==========================================================

Go through everyone and do the thing.

x: xp to give <character> today
c: current normal xp attribute for <character>

*/

&trig.daily.xp xpas=
	@eval 
	strcat( 
		list( 1, sql( u( f.transaction.begin ))), 
		list( 
			search( eplayer=cand( isapproved( ## ), not( isstaff( ## )))), 
			strcat( 
				setq( x, u( f.auto.beats.daily, %i0 )), 
				setq( c, get( %i0/_special.beats.normal )), 
				set( %i0, 
					_special.beats.normal:
					[add( first( %qc ), %qx )] [rest( %qc )] 
				), 
				sql( u( sql.insert.daily-auto, %i0, %!, normal, %qx ))
			)
		), 
		list( 1, sql( u( f.transaction.end )))
	)



// --

&trig.weekly.reset [v( d.xpas )]=
	think setr( m, header( xpas: clearing 'beat' limit )); 
	think setr( n, 
		iter( 
			search( eplayer=
				cand( 
					isapproved( ## ), 
					hasattr( ##, _special.beats_earned.normal ), 
					u( f.at_weeks_end?, ## )
				)
			), 
			cat( 
				name( %i0 ), :, %i0, ::, 
				set( %i0, _special.beats_earned.normal: ), ::, 
				if( strmatch( get( %i0/_special.beats_earned.normal ), ), 
					ansi( hg, OK! ), 
					ansi( n, error )
				)
			), , %r 
		)
	); 
	think setr( o, footer()); 

// .. debug ..
	@mail/quick thenomain/Daily Beats Reset=%qm%r%qn%r%qo; 



/*
================================================================================
== NOTES AND OTHER RANDOM BITS =================================================

Don't trust any code below this line as being done.

Beat Types:
	Normal (default, general xp)
	Player (can be shared among alts)
	
	Cover (for Demon, one per cover)

	&_special.beats.normal <player object>=<total> -<spent>

For each 6 months approved, excluding periods of freezing...
    Period   Beats/Week    Beats/Day
	   1         10         1.4285714285714286
	   2         5          0.7142857142857143
	   3         3          0.42857142857142855
	   4+        1          0.14285714285714285

Limitations of earning: 
	20 Beats/week (normal)
	10 Beats/week (player)


--

Total time active:
	u( <cg>/f.total_secs_approved, <character dbref> )
--

&d.one-day xxx=86400

--

// Week's End calculation: 
// Every 7th day after most recent Approval, reset the 'earned beats this week'.

&f.at_weeks_end? xxx=
	localize( strcat( 
		setq( a, grab( revwords( get( %0/_approval.log ), | ), approved:*, | )), 
		setq( a, elements( %qa, 2, : )), 

		eq( 
			mod( idiv( sub( secs( ), %qa ), v( d.one-day )), 7 ), 
			0 
		)
	))

--

if 'u( f.at_weeks_end?, %0 )', reset the 'xp earned this week' attribute

--

&d.beats.max_weekly xxx=40

--

// how many weeks in a 'period' (nearest number to 6 months)
&d.period.weeks xxx=26

--

// which << 26-week >> period is the character's approval time in? 
// start a 1

&f.current_period xxx=
	...

--

&f.weekly_beats.auto xxx=
	case( u( f.current_period, %0 ), 
		0, 0, 
		1, 10, 
		2, 5, 
		3, 3, 
		1 
	)
	

--

// max beats per week = 40 - auto beats per week
&f.weekly_beats.max_earned xxx=
	sub( v( d.beats.max_weekly ), u( f.weekly_beats.auto, %0 ))

--










================================================================================
== Command: xp/unspend =========================================================

	xp/unspend <name>/<stat>[=<level>] for <reason>

Unspend...
	- finds the most recent spend for <stat>
	- (if <stat> is 'list', then it finds <level>)
	- reduces <stat> by 1 (numeric), entirely (flag), or <level> (list)
	- adds the spent beats to _special.beats.<type>
	- reduces the spent beats from  the 'spent' column

So across the board I would need to check: 
	- the usual validity stuff
	- can I find a spend (-xxx) entry for this stat?
	- is this stat valid after the unspend is done?

--

	n: name passed
	t: type passed ( optional, default 'normal')
	a: amt passed
	r: reason passed

	d: character dbref
	x: current beats (for type) : _special.beats.<type>

//	b: current week's earned beats : _special.beats_earned.<type>
//	f: final weekly award attribute (for type)
//	e: total weekly earnable (for type)

*/

&c.xp/unspend [v( d.xpas )]=$^\+?xp/unspend(.+)$:@pemit %#=
	strcat( 

// xp/unspend <name>/<stat>[=<level>] for <reason>
		setq( 0, trim( %1 )), 
		setq( p, pmatch( first( %q0, / ))), 
		setq( n, before( before( rest( %q0, / ), %bfor%b ), = )), 
		setq( r, rest( %q0, %bfor%b )), 
		setq( l, 
			if( strmatch( %q0, *=* ), before( rest( %q0, = ), %bfor%b ))
		), 

// sheet loc, statpath, stat class
		setq( w, ulocal( v( d.sfp )/f.find-sheet, %qp )),
		setq( s, ulocal( v( d.sfp )/f.statpath.workhorse, %qn, %qp )), 
		setq( c, ulocal( [u( d.sfp )]/f.get-class, %qs )), 

// sql results -- only if %qp and %qs are valid
		setq( q, 
			if( cand( isdbref( %qp ), t( %qs )), 
				last( 
					sql( u( sql.select.spends-stat, %qp, %qs, %ql ), |, ` ), 
					| 
				)
			)
		), 

		DEBUG: %r
		%b p: %qp -- n: %qn -- r: %qr -- l: %ql, %r, 
		%b w: %qw -- s: %qs -- c: %qc, %r, 
		%b q: %qq, %r, 

		case( 1, 
			not( isstaff( %# )), 
			u( .msg, xp/unspend, Staff only ), 

			t( setr( e, ulocal( validate.player, %qp, %qw, 1 ))), 
			u( .msg, xp/unspend, %qe ), 

			not( %qr ), 
			u( .msg, xp/unspend, Unspends must include a reason ), 

			not( %qs ), 
			u( .msg, xp/unspend, 
				Statpath errored: [capstr( lcstr( rest( %qs )))] 
			), 
			
			not( strlen( %qq )), 
			u( .msg, xp/unspend, No record of a spend for that stat ), 

// ok
			strcat( 
				%b beats spent:%b, trim( elements( %qq, 4, ` ), b, 0 ), %r, 
				%b xp type:%b, elements( %qq, 3, ` ), %r, 
				%b reason:%b, elements( %qq, 2, ` ), %r, 
// .. here we need to determine if removing the stat is valid
// .. 1. what would the new stat be?
				%b current stat value:%b, u( .value, %qw, %qs )
// .. 2. validate that
			)			
		)
	)

// --

@set xpas/c.xp/unspend=regexp

// -- 

xp/unspend vera/dex for A Good Reason Clearly
xp/unspend delilah/gift of stealth=unlock for Some Reason Here


// --

/* 
--------------------------------------------------------------------------------
-- SQL Select: Get all spends for '<statpath>' ---------------------------------

All timestamps & xp spent on '<statpath>'; ignore freebies

0: target dbref
1: statpath (with instance)
2: trait value (list only)

*/

&sql.select.spends-stat [v( d.xpas )]=
	SELECT log_time, reason, xp_type, xp_amt 
	FROM xp_log 
	WHERE 
		target_objid='[u( .objid, %0 )]' 
		AND trait_category='[first( %1, . )]' 
		AND trait_name='[rest( %1, . )]' 
		[if( 
			strmatch( ulocal( [u( d.sfp )]/f.get-class, %1 ), list ), 
			AND trait_value='%2' 
		)] 
		AND action='spend' 
	ORDER BY log_time ASC

