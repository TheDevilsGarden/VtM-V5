/*
XP Advancement System

Performs and logs XP spends and gains.

Warning: This is a mess coded in a crunch.

-=-=-=-=-==-=---==-

* Give Passive XP: gain
* Be able to determine: not a spend/gain thing
* Be able to Award XP: gain
* Be able to spend XP: spend
* Be able to unaward XP: ungain
* Be able to unspend: unspend

-=-=-=-=-=-=-=-=-=-=-=-=

&_special.beats.<type> :: <total> -<spent>
&_special.earned_beats.<type> :: <amt earned this week>

Illegal characters: | and ` 

&d.xp_types xpas=normal

-=-=-=-=-=-=-=-=-=-=-=

COMMANDS:
	xp : how much I got? (all types)
	xp <name> : how much they got?

	xp/log [<type>]
	xp/log <name>[=<type>]
	

√	xp/award <name>=<amt> for <reason> : give out dem generic goodies
√	xp/award <name>/<xp type>=<amt> for <reason> : give out dem specific goodies

	xp/spend <stat>=<level> : spend some xps on some mad skillz
	xp/spend <stat>=<level>/<xp type> : spend some specific xpz

√	xp/cost <stat>=<level>[/<xp type>] : how much it be costin'?
√	xp/cost <name>/<stat>=<level> : how much it be costin' for them?

	xp/remove <name>=<amt> for <reason> : take some honey away
	xp/remove <name>/<xp type>=<amt> for <reason> : a specific kind of honey

	xp/unspend <name>=<amt> for <reason> : reduce stat by <amt>, give xp back
	xp/unspend <name>/<xp type>=<amt> for <reason> : bla bla bla




################################################################################
## THE SQL #####################################################################

DROP TABLE IF EXISTS xp_log;

--

CREATE TABLE IF NOT EXISTS xp_log ( 
	target_objid VARCHAR(255) NOT NULL, 
	target_name VARCHAR(255) NOT NULL, 

	enactor_objid VARCHAR(255) NOT NULL, 
	enactor_name VARCHAR(255) NOT NULL, 

	log_time TIMESTAMP NOT NULL DEFAULT NOW(), 

	xp_type VARCHAR(255) NOT NULL, 
	xp_amt DECIMAL(21,17) NOT NULL,

	reasoning VARCHAR(255) NOT NULL,

	PRIMARY KEY (target_objid, log_time) 
) ENGINE=INNODB; 




################################################################################
## THE OBJECT ##################################################################



================================================================================
== SETUP =======================================================================
*/

@create XP Advancement System <xpas>
@fo me=&d.xpas me=num( XP Advancement System <xpas> )
@set xpas=INHERIT SAFE

@fo me=&d.sfp xpas=[num( Stat Functions Prototype <sfp> )]
@fo me=&d.dd xpas=[num( Data Dictionary <dd> )]
@fo me=&d.xpcd xpas=[num( XP Cost Database <xpcd> )]
@fo me=&d.cg xpas=[num( GMC Chargen <cg> )]

@parent xpas=codp
&prefix.sql xpas=sql.
&prefix.validations xpas=validate.



/*
================================================================================
== COMMANDS ====================================================================

	xp : list all xp types (for <name>)
	xp/award : give out xp
	xp/remove : remove xp
	xp/spend : buy stats
	xp/check : output for 'spend' without buying stat/reducing xp


--------------------------------------------------------------------------------
-- XP : Show me things ---------------------------------------------------------

	xp [<name>] : list all xp types (for <name>)

*/


// FILLER FILLER FILLER FILLER FILLER FILLER FILLER 


/*
--------------------------------------------------------------------------------
-- xp/cost ---------------------------------------------------------------------

	xp/cost [<name>/]<stat>[=<value>]

a very temporary thing

*/

&c.xp/cost xpas=$xp/cost *:@pemit %#=[u( f.xp/cost, %0 )]



/*
================================================================================
== SHORT FUNCTIONS =============================================================

--------------------------------------------------------------------------------
-- Short Functions -------------------------------------------------------------
*/

&.isapproved xpas=isapproved( %0, %1 )
&.value xpas=u( v( d.dd )/.value, %0, %1 )
&.msg xpas=ansi( h, <%0>, n, %b%1 )
&.plural xpas=if( eq( %0, 1 ), %0 %1, %0 %2 )
&.lmax xpas=lmax( %0 )


/*
--------------------------------------------------------------------------------
-- Object ID  ------------------------------------------------------------------

The unique identifier for an object, taken from Penn.
Outputs: <#dbref>:<creation time in secondss>

*/

&.objid xpas=localize( 
		if( t( setr( l, locate( %#, %0, * ))), 
			[num( %ql )]:[convtime( get( %ql/created ))], 
			#-1 NOT FOUND 
		)
	)



/* 
================================================================================
== SQL FUNCTIONS ===============================================================

Things related to SQL and converting to and from a table or database.


/*
--------------------------------------------------------------------------------
-- SQL Escape ------------------------------------------------------------------

I removed the nested edits, here. Rhost and TinyMUSH will choke here.

(... should ; also be escaped?)

*/

&f.sql.escape xpas=edit( %0, \\, \\\\\\, ', \\\\', ", \\\\", \%, \\\\\\\% )

/* -- test --

think u( xpas/f.sql.escape, lit(She said, "Oh my god!". \\ I said, "Relax; It's only a test."))


--------------------------------------------------------------------------------
-- HTML Escape -----------------------------------------------------------------

	(not needed at this time)
*/ 

&f.html.escape xpas=
	edit( edit( edit( edit( %0, &, &amp; ), %%, &#37; ), <, &lt; ), >, &gt; )


/*
--------------------------------------------------------------------------------
-- HTML Unescape ---------------------------------------------------------------

	(not needed at this time)
*/

&f.html.unescape xpas=
	edit( edit( edit( edit( %0, &#37;, %% ), &lt;, < ), &gt;, > ), &amp;, & )


/*
--------------------------------------------------------------------------------
-- Time: unix2sql --------------------------------------------------------------

0: secs.

*/

&f.time.unix2sql xpas=if( %0, timefmt( $Y-$m-$d $H:$M:$S $z, %0 ), none )

/* -- test --

think u( xpas/f.time.unix2sql, secs())

think sql( SELECT FROM_UNIXTIME( [secs()] ))
think timefmt( $Y-$m-$d $H:$M:$S $z, secs())


--------------------------------------------------------------------------------
-- Time: sql2unix --------------------------------------------------------------

0: SQL Datetime, string output.

*/

&f.time.sql2unix xpas=sql( SELECT UNIX_TIMESTAMP( '%0' ))

/* -- test --

think u( xpas/f.time.sql2unix, u( sja/f.time.unix2sql, secs() ))

think sql( SELECT UNIX_TIMESTAMP( '[u( xpas/f.time.unix2sql, secs() )]' ))
think secs()


--------------------------------------------------------------------------------
-- Transaction Begin/End -------------------------------------------------------

Technically an sql.* function, but easier to do this way.

*/

&f.transaction.begin xpas=
	strcat( 
		sql( START TRANSACTION ), 
		sql( SET autocommit = 0 )
	)

// --

&f.transaction.end xpas=
	strcat( 
		sql( COMMIT ), 
		sql( SET autocommit = 1 )
	)


/* 
--------------------------------------------------------------------------------
-- SQL: Add to XP Log ----------------------------------------------------------

0: target dbref
1: enactor dbref
2: xp type (probably 'normal')
3: xp amt
4: reason

*/

&sql.xp_log.add xpas=
	INSERT 
		INTO xp_log (
			target_objid, target_name, 
			enactor_objid, enactor_name, 
			xp_type, xp_amt, reasoning
		) 
		VALUES (
			'[u( .objid, %0 )]', '[name( %0 )]', 
			'[u( .objid, %1 )]', '[name( %1 )]', 
			'%2', %3, 
			'%4'
		)
			
			
/* 
--------------------------------------------------------------------------------
-- SQL: Add by Auto-Award System -----------------------------------------------

0: target dbref
1: enactor dbref
2: xp type (probably 'normal')
3: xp amt

*/

&sql.xp_log.auto-add xpas=
	INSERT 
		INTO xp_log (
			target_objid, target_name, 
			enactor_objid, enactor_name, 
			xp_type, xp_amt, reasoning
		) 
		VALUES (
			'[u( .objid, %0 )]', '[name( %0 )]', 
			'[u( .objid, %1 )]', 'Auto-Experience System', 
			'%2', %3, 'Daily Auto'
		)


/* 
--------------------------------------------------------------------------------
-- SQL: Get XP Log for One Character -------------------------------------------

0: target dbref

*/

&sql.xp_log.character xpas=
	SELECT * FROM xp_log WHERE target_objid='[u( .objid, %0 )]'

/* 
--------------------------------------------------------------------------------
-- SQL: Get XP Log of One Type for One Character -------------------------------

A summary used for xp/log 

0: target dbref
1: xp type

*/

&sql.xp_log.type-character xpas=
	SELECT enactor_objid, enactor_name, log_time, xp_amt, reasoning 
	FROM xp_log 
	WHERE target_objid='[u( .objid, %0 )]' 
	AND xp_type='[lcstr( %1 )]'






/* 
################################################################################
## XP VIEWING ##################################################################

Important data:
	v( d.xp_types )
	v( d.beat-to-exp )
	get( <player>/_special.beats.<type> ) : <total> -<spent>



================================================================================
== Command: XP =================================================================

	xp : how much I got? (all types)
	xp <name> : how much they got? (all types)

*/

&c.xp.general xpas=$^\+?xp$:
	@assert cor( isapproved( %# ), isapproved( %#, chargen ))={ 
		@pemit %#=u( .msg, xp, You are not approved nor in chargen )
	}; 

	@pemit %#=
		strcat( 
			wheader( XP & Beats ), %r, 
			iter( v( d.xp_types ), 
				u( display.xp-and-beats.one-line, %#, %i0 ), 
				, %r 
			), 
			wdivider(), %r, 

			if( isapproved( %# ), 
				u( display.approval-deets, %# )
			), %r, 

			wfooter()
		)

@set xpas/c.xp.general=regexp

// -- 

&c.xp.specific xpas=$^\+?xp (.+)$:
	think setr( p, pmatch( trim( %1 ))); 

	@assert cor( isstaff( %# ), strmatch( %#, %qp ))={ 
		@pemit %qp=u( .msg, xp, Staff or self only )
	}; 	

	@assert t( %qp )={ 
		@pemit %qp=u( .msg, xp, '[trim( %1 )]' not found )
	}; 	

	@assert cor( isapproved( %qp ), isapproved( %qp, chargen ))={ 
		@pemit %qp=u( .msg, xp, [name( %qp )] is not approved nor in chargen )
	}; 

	@pemit %#=
		strcat( 
			wheader( XP & Beats for [name( %qp )] ), %r, 
			iter( v( d.xp_types ), 
				u( display.xp-and-beats.one-line, %qp, %i0 ), 
				, %r 
			), %r, 
			wdivider(), %r, 

			if( isapproved( %qp ), 
				u( display.approval-deets, %qp )
			), 

			wfooter()
		)

@set xpas/c.xp.specific=regexp


/* 
--------------------------------------------------------------------------------
-- Display General XP Info -----------------------------------------------------
*/

&display.xp-and-beats.one-line xpas=
	strcat( 
		setq( b, floor( get( %0/_special.beats.%1 ))), 
		setq( x, floor( fdiv( %qb, v( d.beat-to-exp )))), 
		setq( b, mod( %qb, v( d.beat-to-exp ))), 
		ansi( h, titlestr( %1 )), %b, >>, %b, 
		Experiences: %qx%, Beats: %qb 
	)

think u( xpas/display.xp-and-beats.one-line, *vera, normal )

// --

&display.approval-deets xpas=
	localize( strcat( 
		setq( y, strmatch( %#, %0 )), 
		setq( n, name( %0 )), 
		setq( a, u( [v( d.cg )]/f.total_secs_approved, %0 )), 

		if( %qy, You have, %qn has ), %b, 
			been approved for, %b, 
			exptime( %qa ), 
			%r,
		if( %qy, You are, %qn is ), %b, 
			auto-gaining, %b, 
			u( f.auto.beats.weekly, %0 ), %b, 
			Normal Beats per week, %r, 
		if( %qy, You have, %qn has ), %b, 
			earned, %b, 
			default( %0/_special.beats_earned.normal, 0 ), %b, 
			out of, %b, 
			u( f.weekly_beats.max_earnable, %0 ), %b, 
			Normal Beats this week, %r, 
		It will be reset in, %b, 
			u( .plural, 
				sub( 7, u( f.day_in_approval_week, %0 )), 
				day, 
				days 
			), %r, 
	))

think u( xpas/display.approval-deets, pmatch( vera ))

/* 
================================================================================
== Command: xp/log =============================================================

	xp/log [<name>]

For now, shows the entire log of self or <name>. 
This system needs massively overhauled in the future.

p: target (dbref)

*/

&c.xp/log xpas=$^\+?xp/log(.*)$:
	think strcat(
		target:, 
		setr( p, 
			if( 
				t( setr( p, trim( %1 ))), 
				pmatch( %qp ), 
				%# 
			)
		)
	); 

	@assert cor( pmatch( %#, %qp ), isstaff( %# ))={ 
		@pemit %#=u( .msg, xp/log, Self or staff only )
	}; 

	@assert t( %qp )={ 
		@pemit %#=u( .msg, xp/log, '[trim( %1 )]' not found )
	}; 

	think strcat( 
		Log:, setr( l, 
			iter( 
				sql( u( sql.xp_log.type-character, %qp, normal ), `, | ), 
				u( format.xp/log.one-line, %i0 ), 
				`, `
			)
		)
	); 

	@pemit %#=strcat( 
		wheader( XP/Log for [name( %qp )] %(Normal%) ), %r, 
		u( display.xp/log.header ), %r, 
		iter( %ql, u( display.xp/log.one-line, %i0 ), `, %r ), %r, 
		wfooter()
	)

// --

@set xpas/c.xp/log=regexp


/*
--------------------------------------------------------------------------------
-- Format One Line -------------------------------------------------------------
*/

&format.xp/log.one-line xpas=
	strcat( 
		elements( %0, 2, | ), %b, %(, first( elements( %0, 1, | ), : ), %), |, 
		elements( 
			convsecs( u( f.time.sql2unix, elements( %0, 3, | ))), 
			2 3 5 
		), |, 
		trim( fdiv( floor( elements( %0, 4, | )), v( d.beat-to-exp )), b, 0 ), 
		|, 
		elements( %0, 5, | )
	)


/*
--------------------------------------------------------------------------------
-- Display One Line ------------------------------------------------------------

Amt / Reason / Entered By / Date

Reason & Entered By are flexible to the viewer's screen width.

*/


&display.xp/log.header xpas=
	localize( strcat( 
		setq( w, sub( width( %# ), 80 )), 
		rjust( Exp, 5 ), %b%b, 
		ljust( Reason, add( 40, ceil( fdiv( %qw, 2 ))) ), %b, 
		ljust( Entered By, add( 20, floor( fdiv( %qw, 2 )))), %b,
		Date, %r, 
		wdivider()
	))

&display.xp/log.one-line xpas=
	localize( strcat( 
		setq( w, sub( width( %# ), 80 )), 
		rjust( elements( %0, 3, | ), 5 ), %b%b, 
		ljust( elements( %0, 4, | ), add( 40, ceil( fdiv( %qw, 2 ))) ), %b, 
		ljust( elements( %0, 1, | ), add( 20, floor( fdiv( %qw, 2 ))) ), %b,
		elements( %0, 2, | )
	))


/* 
################################################################################
## XP AWARDING #################################################################

Max 4 experiences (20 beats) per week, aka:
	20 - u( f.auto.beats.weekly, <character> )

Store weekly earned on:
	&_special.beats_earned.normal

Valid award:
	lte( 
		add( <amt>, get( <character>/_special.beats_earned.normal )), 
		u( f.weekly_beats.max_earnable, <character> )
	)

'Chargen' people can be awarded anything.



================================================================================
== Command: xp/award ===========================================================

	xp/award <name>=<amt> for <reason> : give out dem generic goodies
	xp/award <name>/<xp type>=<amt> for <reason> : give out dem specific goodies

--

	n: name passed
	t: type passed ( optional, default 'normal')
	a: amt passed
	r: reason passed

	d: character dbref
	x: current beats (for type) : _special.beats.<type>
	b: current week's earned beats : _special.beats_earned.<type>
	f: final weekly award attribute (for type)
	e: total weekly earnable (for type)


*/

&c.xp/award xpas=$^\+?xp/award(.+)$:
	@assert isstaff( %# )={ 
		@pemit %#=u( .msg, xp/award, Staff only )
	}; 

	think strcat( 
		name (w/type):, setr( n, first( %1, = )), %r, 
		type:, 
		setr( t, if( t( setr( t, trim( rest( %qn, / )))), %qt, normal )), %r, 
		name:, setr( n, trim( first( %qn, / ))), %r, 
		amt (w/reason):, setr( a, rest( %1, = )), %r, 
		reason:, setr( r, trim( rest( %qa, %bfor%b ))), %r, 
		amt:, setr( a, trim( first( %qa, %bfor%b )))
	); 

	@assert hastype( setr( p, pmatch( %qn )), PLAYER )={ 
		@pemit %#=u( .msg, xp/award, Could not find '%qn' )
	};

	@assert cor( isapproved( %qp ), isapproved( %qp, chargen ))={ 
		@pemit %#=u( .msg, 
			xp/award, 
			'[name( %qp )]' is not approved nor in chargen 
		)
	}; 

	@assert hastype( setr( p, pmatch( %qn )), PLAYER )={ 
		@pemit %#=u( .msg, xp/award, Could not find '%qn' )
	};

	@assert isint( %qa )={ 
		@pemit %#=u( .msg, xp/award, Award must be an integer )
	};

	@assert strlen( %qr )={ 
		@pemit %#=u( .msg, xp/award, Must include reason )
	};

	@assert cor( strmatch( %qr, *|* ), strmatch( %qr, *`* ))={ 
		@pemit %#=u( .msg, xp/award, May not use | or ` in reason )
	};
	
	@assert strmatch( %qt, normal )={ 
		@pemit %#=u( .msg, xp/award, I can only award 'normal' xp right now )
	}; 

	think strcat( 
		experiences:, setr( x, get( %qp/_special.beats.%qt )), %r, 
		beats earned:, setr( b, get( %qp/_special.beats_earned.%qt )), %r, 
		final award attribute:, setr( f, add( %qa, %qb )), %r, 
		total weekly earnable:, setr( e, u( f.weekly_beats.max_earnable, %qp ))
	); 

	@assert cor( lte( %qf, %qe ), isapproved( %qp, chargen ))={
		@pemit %#=u( .msg, 
			xp/award, 
			'[name( %qp )]' cannot take that many %qt beats. 
			They can only take '[floor( sub( %qe, %qb ))]' more beats 
			for the rest of their week.
		)
	}; 

// add to '_special.beats.<type>'
	@set/quiet %qp=
		_special.beats.%qt:
		[add( first( %qx ), %qa )] [rest( %qx )];

// if approved, add to '_special.beats_earned.<type>'
	@set/quiet %qp=
		_special.beats_earned.%qt:
		[if( isapproved( %qp ), %qf )]; 

// add to xp_log (sql)

	think strcat( 
		tranaction begin, u( f.transaction.begin ), %r, 
		sanitized reason:, setr( s, u( f.sql.escape, %qr )), %r, 
		add to xp_log:, sql( u( sql.xp_log.add, %qp, %#, %qt, %qa, %qs )), %r, 
		tranaction end, u( f.transaction.end )
	); 

// notify enactor and target
	@pemit %#=u( .msg, 
		xp/award, 
		You have awarded '[name( %qp )]' 
		[u( .plural, %qa, Beat, Beats )] 
		for '%qr' 
	); 

	@pemit %qp=u( .msg, 
		xp/award, 
		[moniker( %# )] has just awarded you 
		[u( .plural, %qa, Beat, Beats )] 
		for '%qr' 
	); 


// -- 

@set xpas/c.xp/award=regexp













/* 
################################################################################
## XP PURCHASING ###############################################################



================================================================================
== SETUP =======================================================================
*/

&d.beat-to-exp xpas=5

&d.xp_types xpas=normal

&default.special.xp.normal dd=0 0


/*
--------------------------------------------------------------------------------
-- Restricted Stats ------------------------------------------------------------
*/

&d.restricted.types xpas=iter( lattr( %!/d.restricted.types.*, u( %i0 )))
&d.restricted.types.default xpas=bio

&d.restricted.stats xpas=iter( lattr( %!/d.restricted.stats.*, u( %i0 )))
&d.restricted.stats.default xpas=advantage.integrity merit.status_(*) 

/* 
Eldritch is also restricting all supernatural merits.
This includes human-only merits.

If you'd like to use this, run the code below:

&d.restricted.stats xpas=
	cat( 
		iter( lattr( %!/d.restricted.stats.*, u( %i0 ))), 
		edit( 
			filter( 
				v( d.sfp )/f.hastag?.workhorse, 
				lattr( v( d.dd )/merit.* ), , , 
				get( v( d.dd )/bio.template ) 
			), 
			%(%), %(*%) 
		)
	)

*/


/* CHECK XP COST

--------------------------------------------------------------------------------
-- XP Cost Calculator ----------------------------------------------------------

Brings the formulas and the formula finder together.

0: dbref of sheet (qw)
1: stat-from (Even if it's not used) (qt)
2: stat-to (qv)
3: statpath (qs)

s: statpath without instance
v: main.value.list
f: formula's attribute name

*/

&f.cost.calculator xpas=
	localize( strcat( 
		setq( s, u( v( d.sfp )/f.statpath-without-instance, trim( %3, l, _ ))), 
		setq( f, u( f.formula_finder, %qs, %0 )), 
		setq( v, first( get( v( d.dd )/%qs ), | )), 

		if( t( %qf ), 
			u( 
				v( d.xpcd )/%qf, 
				%0, %1, %2, last(%q3, .), %qv 
			), 

			%qf
		)
	))


/*
--------------------------------------------------------------------------------
-- XP Formula Finder -----------------------------------------------------------

This code is meant to find out which of the xp.<blah> function to look up for any given statpath.  It only finds the name.

>>> XP FORMULAS ARE STORED ON THE XPCD <<<

Below is the ?.?.?[~<template>] finder test.

--

&xp.skill.?.?~[get( %#/_bio.template)] xpcd=1

think 
	[setq( z, get( %#/_bio.template ))]
	[setr( t, setr( s, skill.academics.history ))] --> 
	[setr( n, lnum( words( %qs, . ), 2 ))] --> 
	[setr( n, iter( %qn, setr( t, replace( %qt, %i0, ?, . ))))] --> 
	[setr( n, [iter( %qn, %i0~%qz )] %qn )] --> 
	[first( filter( xpas/fil.formula_finder, %qn ))]

&xp.skill.?.?~[get( %#/_bio.template)] xpcd=

--

0: dd.statpath_(without instance)
1: dbref of sheet

t: sheet template

s: temp statpaths for the ? wildcard
x: temp statpaths for the degrading search

*/

&f.formula_finder xpas=
	localize( strcat( 

// set registers
		setq( t, get( %1/_bio.template )), 

		setq( s, %0 ), 
		setq( s, 
			filter( fil.formula_finder, 
				iter( 
					lnum( words( %0, . ), 2 ), 
					setr( s, replace( %qs, %i0, ?, . ))
				)
			)
		), 
		setq( s, 
			cat( 
				iter( %qs, %i0~%qt ), 
				%qs
			)
		), 
		setq( s, filter( fil.formula_finder, %qs )), 

		setq( x, %0 ), 
		setq( x, 
			filter( fil.formula_finder, 
				iter( 
					lnum( words( %0, . ), 1 ), 
					setr( x, ldelete( %qx, %i0, . ))
				)
			)
		), 
		setq( x, 
			cat( 
				iter( %qx, %i0~%qt ), 
				%qx
			)
		), 
		setq( x, filter( fil.formula_finder, %qx )), 

// TEST
		case( 1, 

// xp.<statpath>~<template>
			t( filter( fil.formula_finder, %0~%qt )), 
			xp.%0~%qt, 

// xp.<statpath>
			t( filter( fil.formula_finder, %0 )), 
			xp.%0, 

// xp.<type>.?[~<template>]
			t( %qs ), 
			xp.[first( %qs )], 

// xp.<type>[~<template>], like above but without the ? involved
			t( %qx ), 
			xp.[first( %qx )], 

// else: error
			#-1 No Experience costs found 
		)
	))

// --

&fil.formula_finder xpas=hasattr( v( d.xpcd ), xp.%0 )

// --
// &xp.skill.?.?~[get( %#/_bio.template)] xpcd=1
// think u( xpas/f.formula_finder, %#, skill.academics.history )
// &xp.skill.?.?~[get( %#/_bio.template)] xpcd=


/*
--------------------------------------------------------------------------------
-- XP/COST ---------------------------------------------------------------------

Cost (and therefore Spend) does a cheat I use in other places: Its support functions pull directly from the set registers, instead of passing them.  This may cause problems in the future.

0: [<player>/]<stat>[=<value>]
p: player dbref
n: stat name
v: requested value (new)

w: where's the sheet
s: stat path
t: trait's value (current, from the sheet)
c: cost

e: error message, if any
x: current xp attribute

*/

&f.xp/cost xpas=
	strcat( 

// break %0 down to p, n, v
		setq( p, first( %0, = )), 
		setq( v, rest( %0, = )), 
		setq( n, rest( %qp, / )), 
		setq( p, first( %qp, / )), 
		if( not( t( %qn )), 
			strcat( setq( n, %qp ), setq( p, %# )),
			setq( p, pmatch( %qp ))
		), 

// get sheet location, statpath
		setq( w, ulocal( v( d.sfp )/f.find-sheet, %qp )),
		setq( s, ulocal( v( d.sfp )/f.statpath.workhorse, %qn, %qp )), 

// current value, next value, estimated cost
		setq( t, ulocal( .value, %qw, %qs )), 
		if( 
			not( t( %qv )), 
			setq( v, ulocal( f.stat.next_rank, %qw, _%qs ))
		), 
		setq( c, ulocal( f.cost.calculator, %qw, %qt, %qv, %qs )), 

// current 'xp' attribute
		setq( x, get( %qw/_special.beats.normal )), 

		case( 1, 
			t( setr( e, ulocal( validate.player, %qp, %qw, 1 ))), 
			u( .msg, xp/cost, %qe ), 

			t( setr( e, ulocal( validate.stat, %qw, %qs, %qt, %qv ))), 
			u( .msg, xp/cost, %qe ), 

			t( setr( e, ulocal( validate.value ))), 
			u( .msg, xp/cost, %qe ), 

			t( setr( e, ulocal( validate.cost, %qc ))), 
			u( .msg, xp/cost, %qe ), 

			u( .msg, xp/cost, 
				u( display.xp/cost, %qp, %qn, %qs, %qv, %qt )
			)

		)
	)

// -- test --

think u( xpas/f.xp/cost, strength )
think u( xpas/f.xp/cost, *vera/strength=1 )

/*
--------------------------------------------------------------------------------
-- Display: XP/Cost ------------------------------------------------------------

0: player dbref (qp)
1: stat name as entered (qn)
2: statpath (qs)
3: requested value (qv)
4: trait's current value (qt)

e: error check results
f: other error check results

*/

&display.xp/cost xpas=
	strcat( 
		The cost, %b,  

		if( not( strmatch( %#, %0 )), 
			cat( for, name( %0 ), )
		), 

		case( 
			u( v( d.sfp )/f.get-class, %2 ), 

			list, 
			strcat( 
				to add %3, %b, 
				%(, u( u( d.dd )/_class_translate_list, %2, %3 ), %), 
				%b, to, %b, 
				statname ( %0/%1 )
			), 

			cat( 
				to raise, 
				statname( %0/%1 ), 
				from, 
				if( strlen( %4 ), %4, 0 ), 
				to %3 
			)
		), %b, 

		is %qc Experiences., 

// .. can't afford?
		setq( e, u( validate.spend, %qc, %qx )), 
		setq( f, u( validate.restricted, %qs, %qv )), 
		case( 1, 
			cand( %qe, %qf ), %b%(%qe%, %qf.%), 
			t( %qe ), %b%(%qe.%), 
			t( %qf ), %b%(%qf.%) 
		)
	)


/*
--------------------------------------------------------------------------------
-- XP Next Stat Rank -----------------------------------------------------------

For our next trick, we'll take <sheet> and <stat> and return the next logical value for that stat.  For instance, a skill from 0 to 1, Stunning Looks from 2 to 4.  It will return #-1 should the person be at the top of the list, as well as other errors.

If a stat whose value set is # can always be raised.

Needs to handle specialties properly.  The XP cost calculator does, too.

0: sheet dbref
1: _sheet.statpath_(with_instance)

d: dd statpath, without instance
s: value of stat on sheet
v: valid values
n: next rank, if applicable
*/

&f.stat.next_rank xpas=
	localize( strcat( 
		setq( d, u( v( d.sfp )/f.statpath-without-instance, trim( %1, l, _ ))), 
		setq( s, first( udefault( %0/%1, 0 ), . )), 
		setq( v, first( u( v( d.dd )/%qd ), | )), 
		setq( n, extract( %qv, inc( match( %qv, %qs, . )), 1, . )), 

		case( 1, 
			strmatch( %qv, # ), inc( %qs ), 
			strmatch( %1, _skill.*.* ), inc( %qs ), 
			not( t( %qn )), #-1 That stat can't go any higher, 
			gt( %qs, last( %qv, . )),  #-1 Stat Already Above Max Level, 
			%qn 
		 )
	))




/*
================================================================================
== VALIDATIONS =================================================================


--------------------------------------------------------------------------------
-- Validate: Player ------------------------------------------------------------

Everything there is to validate about a player.  Sheet, approved, staff status, etc.  Staff can check or set non-approved players.

0: character dbref (qp)
1: sheet dbref (qw)
2: 1 if we're just checking; allow unapproved players to check

*/

&validate.player xpas=
	case( 0, 
		cor( isstaff( %# ), match( %0, %# )), 
		Yourself only, 

		t( %1 ), 
		Could not find a sheet, 

		cor( %2, isapproved( %0, approved ), isstaff( %# )), 
		Must be approved for play to spend Experiences 
	)


/*
--------------------------------------------------------------------------------
-- Validate: Stat --------------------------------------------------------------

Uses 'f.statcheck' for almost all of it.

0: sheet dbref (qw)
1: statpath (qs)
2: trait's current sheet value (qt)
3: requested value (new) (qv)

v: chargen's stat validation
*/

&validate.stat xpas=
	localize( strcat( 

		setq( v, 
			u( v( d.cg )/f.statcheck, 
				%0, _%1, 
				case( 
					u( v( d.sfp )/f.get-class, %1 ), 
					numeric, sub( %3, %2 ), 
					%3 
				)
			)
		), 

		case( 0, 
			t( %1 ), Stat not found, 
			not( strmatch( %3, #-* )), capstr( lcstr( rest( %3 ))), 

			cor( t( first( %qv, . )), strmatch( %3, )), 
			capstr( lcstr( rest( first( %qv, . )))), 

			t( elements( %qv, 2, . )), 
			Can't set the stat outside character generation, 

			t( elements( %qv, 3, . )), 
			Stat cannot be taken by your template, 

			t( elements(%qv, 4, . )), 
			capstr( lcstr( rest( elements( %qv, 4, . ))))
		)
	))


/*
--------------------------------------------------------------------------------
-- Validate: Cost --------------------------------------------------------------

0: calculated cost (qc)

*/

&validate.cost xpas=
	case( 1, 
		cand( isstaff( %# ), not( t( %0 ))), 
		This stat has no Experience cost and must be set using 'stat/set', 

		not( %0 ), 
		This stat has no Experience cost and must be set by a staffer 
	)


/*
--------------------------------------------------------------------------------
-- Validate: Value -------------------------------------------------------------

To be honest, I'm not sure why this is here.

*/

&validate.value xpas=
	localize( strcat( 
		setq( c, u( v( d.sfp )/f.get-class, %qs )), 

		case( %qc, 

			list, 
			case( 0, 
				t( %qv ), 
				capstr( lcstr( rest( %qv ))), 

				not( match( %qt, %qv, . )), 
				You already have the stat at that level
			), 

			numeric, 
			case( 0, 
				t( %qv ), 
				capstr( lcstr( rest( %qv ))), 

				isint( %qv ), 
				Raise must be numeric, 

				gt(%qv, %qt), 
				Stat must be raised
			), 

			string, 
			Cannot raise string stats, 

			flag, 
			I don't know how to process flags yet,

			Uncaptured stat class type in 'validate.value' 

		)
	))

/*
--------------------------------------------------------------------------------
-- Validate: Spend -------------------------------------------------------------

After we've validated everything else, can the person afford it?

0: cost (qc), in experiences
1: experiences attribute (qx), in beats

*/

&validate.spend xpas=
	if( 
		gt( %0, fdiv( ladd( %1 ), v( d.beat-to-exp ))), 
		Not enough Experiences 
	)


/*
--------------------------------------------------------------------------------
-- Validate: Restricted --------------------------------------------------------

Returns error if stat is "restricted", meaning that only staff may 
buy it for them.

ELDRITCH HOUSE-RULE: Numeric traits of 4+ are also restricted

0: stat path (qs)
1: requested value (qv)

*/

&validate.restricted xpas=
	localize(
		case( 1, 
			isstaff( %# ), @@( ignore entirely ), 

			t( match( u( d.restricted-types ), first( %0, . ))), 
			Stats of this type must be purchased for you by a staffer, 

			t( match( u( d.restricted-stats ), %0 )), 
			This stat must be purchased for you by a staffer, 

/* eldritch house rule; uncomment if you'd like this
			cand( 
				strmatch( u( v( d.sfp )/f.get-class, %0 ), numeric ), 
				gte( %1, 4 )
			), 
			Stats 4+ must be set by staff 
*/
		)
	)






















/*
################################################################################
## AUTO XP GAINING #############################################################


&d.one-day xpas=86400
&d.one-week xpas=604800
&d.beats.max_weekly xpas=20
&d.period.weeks xpas=26


================================================================================
== AUTO ========================================================================
*/


// Week's End calculation: 
// Every 7th day after most recent Approval, reset the 'earned beats this week'.

&f.at_weeks_end? xpas=eq( u( f.day_in_approval_week, %0 ), 0 )

&f.day_in_approval_week xpas=
	localize( strcat( 
		setq( a, grab( revwords( get( %0/_approval.log ), | ), approved:*, | )), 
		setq( a, elements( %qa, 2, : )), 
		mod( idiv( sub( secs( ), %qa ), v( d.one-day )), 7 )
	))



// which << 26-week >> period is the character's approval time in? 
// start at 1

&f.current_period xpas=
	ceil( fdiv( 
		u( [v( d.cg )]/f.total_secs_approved, %0 ), 
		mul( v( d.one-week ), inc( v( d.period.weeks )))
	))



&f.auto.beats.weekly xpas=
	case( u( f.current_period, %0 ), 
		0, 0, 
		1, 10, 
		2, 5, 
		3, 3, 
		1 
	)
	

&f.auto.beats.daily xpas=
	fdiv( u( f.auto.beats.weekly, %0 ), 7 )


// max beats per week = 20 - auto beats per week
&f.weekly_beats.max_earnable xpas=
	sub( v( d.beats.max_weekly ), u( f.auto.beats.weekly, %0 ))


// Yup! That works! That's the setup stuff. Now we can calculate 
// everything we need to for xp awards, et al.




&f.approved_characters xpas=
	search( eplayer=cand( isapproved( ## ),  not( isstaff( ## ))))


	
/*

@daily xpas=
	@trigger %!/trig.daily.xp; 
	@trigger %!/trig.weekly.reset; 

*/


/* 
================================================================================
== AUTO: ADD DAILY XP ==========================================================

Go through everyone and do the thing.

x: xp to give <character> today
c: current normal xp attribute for <character>

*/

&trig.daily.xp xpas=
	@eval 
	strcat( 
		list( 1, sql( u( f.transaction.begin ))), 
		list( 
			search( eplayer=cand( isapproved( ## ), not( isstaff( ## )))), 
			strcat( 
				setq( x, u( f.auto.beats.daily, %i0 )), 
				setq( c, get( %i0/_special.beats.normal )), 
				set( %i0, 
					_special.beats.normal:
					[add( first( %qc ), %qx )] [rest( %qc )] 
				), 
				sql( u( sql.xp_log.auto-add, %i0, %!, normal, %qx ))
			)
		), 
		list( 1, sql( u( f.transaction.end )))
	)



// --

&trig.weekly.reset xpas=
	@eval 
		list( 
			search( eplayer=cand( u( f.at_weeks_end?, ## ), isapproved( ## ))), 
			set( %i0, _special.beats_earned.normal: )
		)













/*
================================================================================
== NOTES AND OTHER RANDOM BITS =================================================

Don't trust any code below this line as being done.

Beat Types:
	Normal (default, general xp)
	Player (can be shared among alts)
	
	Cover (for Demon, one per cover)

	&_special.beats.normal <player object>=<total> -<spent>

For each 6 months approved, excluding periods of freezing...
    Period   Beats/Week    Beats/Day
	   1         10         1.4285714285714286
	   2         5          0.7142857142857143
	   3         3          0.42857142857142855
	   4+        1          0.14285714285714285

Limitations of earning: 
	20 Beats/week (normal)
	10 Beats/week (player)


--

Total time active:
	u( <cg>/f.total_secs_approved, <character dbref> )

[3/8/15, 10:13:06 PM] Manu: Need to decide when XP resets for gaining.
[3/8/15, 10:13:32 PM] Kent: Tuesday at 4:53 am.
[3/8/15, 10:13:34 PM] Kent: Eastern.
[3/8/15, 10:13:34 PM] Manu: Like, when it resets to "you have now gained 0 XP this week".
[3/8/15, 10:13:50 PM] Manu: Hah.
[3/8/15, 10:14:08 PM] Kent: I could base it on their most recent approval, but I could also jam a hot poker in my eye.

--

&d.one-day xxx=86400

--

// Week's End calculation: 
// Every 7th day after most recent Approval, reset the 'earned beats this week'.

&f.at_weeks_end? xxx=
	localize( strcat( 
		setq( a, grab( revwords( get( %0/_approval.log ), | ), approved:*, | )), 
		setq( a, elements( %qa, 2, : )), 

		eq( 
			mod( idiv( sub( secs( ), %qa ), v( d.one-day )), 7 ), 
			0 
		)
	))

--

if 'u( f.at_weeks_end?, %0 )', reset the 'xp earned this week' attribute

--

&d.beats.max_weekly xxx=40

--

// how many weeks in a 'period' (nearest number to 6 months)
&d.period.weeks xxx=26

--

// which << 26-week >> period is the character's approval time in? 
// start a 1

&f.current_period xxx=
	...

--

&f.weekly_beats.auto xxx=
	case( u( f.current_period, %0 ), 
		0, 0, 
		1, 10, 
		2, 5, 
		3, 3, 
		1 
	)
	

--

// max beats per week = 40 - auto beats per week
&f.weekly_beats.max_earned xxx=
	sub( v( d.beats.max_weekly ), u( f.weekly_beats.auto, %0 ))

--


*/
