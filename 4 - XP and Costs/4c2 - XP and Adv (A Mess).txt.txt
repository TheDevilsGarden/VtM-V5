/*
XP Timers

How often can you raise a stat by one level?

If you don't want to use this system, do not install anything here.

Hopefully the system will ignore timers if the data is null.

--

0: target character object dbref
1: full statpath (with instance)
returns: - or 0 if OK to buy, + if not

--

Supernatural Tolerance - 8 weeks
	&timer.<supernatural tolerance> xpas=4838400 - <last purchase>

Demons can only buy 3 Embeds/Exploits per month, no more than 2 of each
	I think this would work ...
		&timer.embed xpas=2419200 - <oldest of 3 embeds/exploits> 
			OR gte( <embeds in that time>, 2 )
		&timer.explot xpas=2419200 - <oldest of 3 embeds/exploits> 
			OR gte( <exploits in that time>, 2 )

Status and Mystery Cult Initiation cannot be raised for 30 days after 
character approval.
	&timer.merit.status_() xpas=
		max( 
			sub( 2419200, u( f.last-purchase, %0, %1 )), 
			sub( 2419200, u( v( d.cg )/f.total_secs_approved, %0 ))
		)
	&timer.merit.mystery_cult_initiation_() xpas=
		max( 
			sub( 2419200, u( f.last-purchase, %0, %1 )), 
			sub( 2419200, u( v( d.cg )/f.total_secs_approved, %0 ))
		)

*/

// ----------------------------------------------------------------------------
// 0: character dbref
// 1: full statpath

&f.last-purchase xpas=
	u( f.time.sql2unix, 
		sql( u( sql.select.last-touched, %0, %1 ))
	)

&f.time-until-next-purchase xpas=
	min( 0, 
		
	)


/*
================================================================================
== TIMERS ======================================================================

0: target character object dbref
1: full statpath (with instance)
returns: - or 0 if OK to buy, + if not

We're putting these on the Costs Database <xpcd>

*/

// Pretty much everything - 4 weeks

&timer.? xpcd=sub( 2419200, u( f.last-purchase, %0, %1 ))

// Status and Mystery Cult Initiation cannot be raised for 
// 4 weeks after character approval.

&timer.merit.status_() xpcd=
	max( 
		sub( 2419200, u( f.last-purchase, %0, %1 )), 
		sub( 2419200, u( v( d.cg )/f.total_secs_approved, %0 ))
	)

&timer.merit.mystery_cult_initiation_() xpcd=
	max( 
		sub( 2419200, u( f.last-purchase, %0, %1 )), 
		sub( 2419200, u( v( d.cg )/f.total_secs_approved, %0 ))
	)




























/*
--------------------------------------------------------------------------------
-- Timer Formula Finder --------------------------------------------------------

Basically the 'XP Formula Finder'.

...









================================================================================
== UNSPEND =====================================================================

* Check unspend is for 'normal' xp only (to start)
	- Never for 'player' xp. Once that's converted, that's it.
* Turn action from 'Spend' to 'Unspend'
* Add 'Unspent by (info) for (reason)' at the end of comment
	- Yes, this is bad design. Who touched it/why should be in separate table.
* Add beats from table to offset in &_special.beats.<type>
* Call it a day

Wizard-only.

l: log entry
a: action
t: xp type
v: xp amt
o: target objid
d: target dbref
c: target current beats
x: stat class
y: current value

	xp/unspend <entry num> for <reason>

*/

&c.xp/unspend [v( d.xpas )]=$^\+?xp/unspend(.*)$:
	think strcat( 
		entry num:, setr( e, first( %1 )), %r, 
		reason:, setr( r, trim( rest( %1, for ))), %r, 
	); 

	@assert cand( isint( %qe ), gt( %qe, 0 ))={
		@pemit %#=u( .msg, xp/unspend, Entry num must be postitive integer ) 
	}; 

	@assert strlen( %qr )={ 
		@pemit %#=u( .msg, xp/unspend, Must include a reason ) 
	}; 

// check for information about xp_log and the target
	think strcat( 
		sql log:, setr( l, sql( u( sql.select.entry_num, %qe ), `, | )), %r, 
		target objid:, setr( o, elements( %ql, 3, | )), %r, 
		target dbref:, setr( d, first( %qo, : )), %r, 
		unspent?:, setr( 0, sql( sql.select.unspend.check, %qe )), %r, 
	); 

	@assert strlen( %ql )={ 
		@pemit %#=u( .msg, xp/unspend, No such entry number found ) 
	}; 

	@assert not( strmatch( %ql, #-* ))={ 
		@pemit %#=u( .msg, xp/unspend, 
			SQL query failed - please contact a coder 
		) 
	}; 

	@assert cor( isstaff( %# ), strmatch( %#, %qd ))={ 
		@pemit %#=u( .msg, xp/unspend, Staff or self only ) 
	}; 

/* possibly:
	@assert isstaff( %#, wizard )={ 
		@pemit %#=u( .msg, xp/unspend, Wizard only ) 
	}; 
*/

	@assert cand( isdbref( %qd ), strmatch( %qo, u( .objid, %qd )))={ 
		@pemit %#=u( .msg, xp/unspend, Target no longer exists ) 
	}; 

	@assert not( %q0 )={ 
		@pemit %#=u( .msg, xp/unspend, 
			This has already been unspent in 'xp/log %q0' 
		); 
	}; 

// check that the action and xp type are valid
	think strcat( 
		action:, %b, setr( a, elements( %ql, 7, | )), %r, 
		xp type:, %b, setr( t, elements( %ql, 12, | )), %r, 
	); 

	@assert cor( strmatch( %qa, spend ), strmatch( %qa, freebie ))={ 
		@pemit %#=u( .msg, xp/unspend, 
			Action is '%qa'%; must be 'spend' or 'freebie' 
		) 
	}; 

	@assert strmatch( %qt, normal )={ 
		@pemit %#=u( .msg, xp/unspend, XP type is '%qt'%; must be 'normal' ) 
	}; 

// everything else is okay; display basic info
	think strcat( 
		xp (beats) spent:, setr( s, elements( %ql, 6, | )), %r, 
		current beats:, setr( b, get( %qd/_special.beats.%qt )), %r, 

		stat category:, setr( 1, elements( %ql, 9, | )), %r, 
		stat name:, setr( 2, elements( %ql, 10, | )), %r, 
		statpath:, setr( p, %q1.%q2 ), %r, 
		stat class:, setr( c, ulocal( v( d.sfp )/f.get-class, %qp )), %r, 
		logged value:, setr( v, elements( %ql, 11, | )), %r, 
		current value:, setr( x, getstat( %qd/%q2, permanent )), %r, 
		new value:, 
			setr( m, 
				udefault( f.xp/unspend.%qc, 
					#-1 Can't convert this stat type, 
					%qx, %qv 
				)
			), 
		%r, 
	); 

	@assert not( strmatch( %qm , #-* ))={ 
		@pemit %#=u( .msg, xp/unspend, rest( %qm )); 
	}; 

	@pemit %#=strcat( 
		wheader( Unspend: [statname( %q2 )] \[[capstr( %q1 )]\] ), %r, 

		ansi( h, statname( %q2 )), :%b, '%qx', %b->%b, '%qm', 
		%r%r, 
		Refunding, %b, 
			case( %qa, 
				freebie, 
				no Exp %(freebie%), 
				strcat( 
					div( %qs, v( d.beat-to-exp )), %b, Exp, %b, 
					%(, floor( %qs ), %b, beats%), 
				)
			), %b, 
			for reason, %b', %qr, ', 
		%r, 
/*
		Beats from:, %b, round( ladd( %qb ), 1 ), 
			%b%(, 
			round( first( %qb ), 1 ), %bearned, %,%b, 
			round( abs( rest( %qb )), 1 ), %bspent, 
			%), 
		%r,  
		Beats to:, %b %b, 
			setq( 3, cat( first( %qb ), add( rest( %qb ), %qs ))), 
			round( ladd( %q3 ), 1 ), 
			%b%(, 
			round( first( %q3 ), 1 ), %bearned, %,%b, 
			round( abs( rest( %q3 )), 1 ), %bspent, 
			%), 
		%r, 
*/
		wfooter( )
	); 

	@assert strmatch( %#, pmatch( thenomain ))={ 
		@@ do nothing more
	}; 
	
	@pemit %#=u( .msg, xp/unspend, Hello%, Thenomain ); 






/*
e: entry num, as entered
r: reason, as entered

l: sql log of entry_num = %qe
o: target objid
d: target dbref
0: entry_num matching existing 'unspend' (if any)

a: action
t: xp type

s: xp (beats) spent
b: current ('normal') beats on target (%qd)

p: stat path ('category.name')
1: stat category
2: stat name
c: stat class
v: logged stat value added/changed to, from sql log (%ql)
x: current stat value, from target (%qd)

m: new stat value (calculated)

3: unspend log entry insert
4: unspend log reference insert 
*/


// record into 'xp_log'
	@pemit %#=strcat( 
		start:, u( f.transaction.begin ), %r, 
		log entry:, setr( 3, 
				sql( u( sql.insert.unspend.log,  
					%qd, %#, %qt, %qs, %qp, %qr, %qv 
				)) 
		), %r, 
		reference:, setr( 4, 
			if( not( strlen( %q3 )), 
				sql( u( sql.insert.unspend.reference, %qe )), 
				#-1 log entry failed 
			)
		), %r, 
		commit:, u( f.transaction.end ), %r, 
	); 

	@pemit %#=
		u( .msg, xp/unspend, 
			unspend entry: %q3 %runspend reference: %q4 %r 
		); 







// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=--=-==-=-=--=-==-=--=-=
/*
This section does not (repeat NOT) check for the validity of the end result. 
This is especially important for the 'list' class of stats.
*/
&f.xp/unspend.numeric [v( d.xpas )]=
	if( strmatch( %0, %1 ), 
		trim( dec( %1 ), 0, l ), 
		#-1 Current value different than added value 
	)
&f.xp/unspend.list [v( d.xpas )]=
 	if( t( match( %0, %1, . )), 
		ldelete( %0, match( %0, %1, . ), . ), 
		#-1 Added value does not exist in current list 
	)


/*

I am going to have to add a second table to link the 'entry num' of the 
spend/freebie to the 'entry num' of the unspend. If such a link exists, then do 
not let a second unspend go through.

Don't allow the 'spend' (or 'freebie') in the parent table (xp_log) if there is 
an associated 'unspend'. Allow the system to delete an 'unspend' regardless. So 
if for an unlikely reason, a 'spend' needs deleted from the table, delete its 
'unspend' first.

--

DROP TABLE IF EXISTS xp_log_unspend;

CREATE TABLE IF NOT EXISTS xp_log_unspend ( 
	entry_num_spend BIGINT UNSIGNED NOT NULL, 
	entry_num_unspend BIGINT UNSIGNED NOT NULL, 

	PRIMARY KEY (entry_num_spend, entry_num_unspend), 

	FOREIGN KEY (entry_num_spend) 
		REFERENCES xp_log (entry_num) 
		ON DELETE RESTRICT 
		ON UPDATE CASCADE, 
	FOREIGN KEY (entry_num_unspend) 
		REFERENCES xp_log (entry_num) 
		ON UPDATE CASCADE 
) ENGINE=INNODB; 

*/

// --=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-===-=-=-=-=

/*
--------------------------------------------------------------------------------
-- SQL Insert: Unspend Some Experience -----------------------------------------

0: target dbref
1: enactor dbref (may be the same)
2: xp type (probably 'normal') - must be 'normal' for now
3: xp amt
4: full statpath (with instance)
5: reason (probably "'unspent <entry num> for reason '<reason>'") 
6: value set/reduced

do not forget to 'start transaction'

*/

&sql.insert.unspend.log [v( d.xpas )]=
	INSERT 
		INTO xp_log (
			target_objid, target_name, 
			enactor_objid, enactor_name, 
			xp_type, xp_amt, 
			trait_category, trait_name, trait_value, 
			action, reason
		) 
		VALUES (
			'[u( .objid, %0 )]', '[name( %0 )]', 
			'[u( .objid, %1 )]', '[name( %1 )]', 
			'%2', %3, 
			'[lcstr( first( %4, . ))]', '[lcstr( rest( %4, . ))]', '%6', 
			'unspend', 
			'%5'
		)

// apply the entry_num here:

&sql.insert.unspend.reference [v( d.xpas )]=
	INSERT 
		INTO xp_log_unspend (entry_num_spend, entry_num_unspend) 
		VALUES (%0, LAST_INSERT_ID( ))

// do not forget to 'f.transaction.begin' and 'f.transaction.end'

/* 

SET @a=0;
UPDATE test_table SET id=(@a:=@a+1);
SELECT @a; 

-- >> ALTER TABLE test_table AUTO_INCREMENT=<that value>; 
*/

&sql.select.unspend.check [v( d.xpas )]=
	SELECT entry_num_unspend 
		FROM xp_log_unspend 
		WHERE entry_num_spend=%0
